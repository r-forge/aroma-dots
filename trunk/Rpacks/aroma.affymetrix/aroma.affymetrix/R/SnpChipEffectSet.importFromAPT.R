###########################################################################/**
# @set "class=SnpChipEffectSet"
# @RdocMethod importFromAPT
#
# @title "Imports probeset summaries from an Affymetrix Power Tool (APT) result file"
#
# \description{
#  @get "title" named *.summary.txt and generated by the
#  gtype-probeset-genotype command line tool.
# }
#
# @synopsis
#
# \arguments{
#   \item{filename}{The filename of the dChip result file.}
#   \item{path}{An optional path to the file.}
#   \item{...}{Not used.}
#   \item{skip}{If @TRUE, already imported arrays will be skipped.}
#   \item{verbose}{See @see "R.utils::Verbose".}
# }
#
# \value{
#  Returns an @see "SnpChipEffectSet".
# }
#
# @author
#
# \seealso{
#   @seeclass
# }
#*/###########################################################################
setMethodS3("importFromAPT", "SnpChipEffectSet", function(static, filename, path=NULL, ..., skip=TRUE, verbose=FALSE) {
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Local functions
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  readAptHeader <- function(con, ...) {
    nrows <- 0;
    res <- list();
    while(TRUE) {
      line <- readLines(con, n=1);
      if (nchar(line) == 0)
        break;
      nrows <- nrows + 1;
      if (regexpr("^##", line) != -1)
        break;
      if (regexpr("^#%", line) == -1) {
        throw("File format error: Not a header line in an APT *.summary.txt file: ", line);
      }

      line <- gsub("^#%", "", line);
      line <- strsplit(line, split="=")[[1]];
      name <- line[1];
      value <- paste(line[-1], collapse="=");
      res[[name]] <- value;
    }

    attr(res, "nrows") <- nrows;
    
    res;    
  } # readAptHeader()

  readUnitGroups <- function(con, cdf, nbrOfColumns, verbose=FALSE, ...) {
    verbose && enter(verbose, "Reading unit group names (only)");
    seek(con, where=dataOffset, rw="read");
    # Skip the last empty column (due to the extra tab outputted by dChip)
    colClasses <- rep("NULL", nbrOfColumns);
    colClasses[1] <- "character";
    names <- read.table(file=con, colClasses=colClasses, sep=sep, header=FALSE);
    names <- unlist(names, use.names=FALSE);
    nrows <- length(names);
    verbose && cat(verbose, "Number of rows read: ", nrows);

    # Extract unit names
    pattern <- "(.*)-(A|B)$";
    unitNames <- gsub(pattern, "\\1", names);
    groups <- gsub(pattern, "\\2", names);
    uUnitNames <- unique(unitNames);
    nbrOfUnits <- length(uUnitNames);
    verbose && printf(verbose, "Unit names [%d]:\n", nbrOfUnits);
    verbose && str(verbose, uUnitNames);
    verbose && exit(verbose);

    # Get the dChip-to-CDF (unit, group) map
    cdfUnitNames <- getUnitNames(cdf);
    units <- match(unitNames, cdfUnitNames);
    groups <- c("A"=1, "B"=2)[groups];
    if (any(is.na(groups)))
      throw("File format error: Detected groups without group names.");
    groups[is.na(groups)] <- 1;
    rm(cdfUnitNames, unitNames);

    # Validate
    verbose && enter(verbose, "Validating unit names towards the chip type");
    uUnits <- unique(units);
    unknown <- which(is.na(uUnits));
    nbrOfUnknown <- length(unknown);
    verbose && cat(verbose, "Number of unknown unit names: ", nbrOfUnknown);
    if (nbrOfUnknown == length(uUnits)) {
      throw("None of the read unit names belongs to the '", getChipType(cdf),
                                                   "' CDF file: ", pathname);
    } 

    if (nbrOfUnknown > 0) {
      msg <- sprintf("Data file contains %d unknown unit names: %s", nbrOfUnknown, paste(uUnitNames[unknown], collapse=", "));
      throw(msg);
    }
    rm(uUnitNames, unknown);

    # Store only known units
    keep <- !is.na(units);
    units <- units[keep];
    groups <- groups[keep];
    verbose && exit(verbose);

    # Garbage collect
    gc <- gc();
    verbose && print(verbose, gc);

    list(units=units, groups=groups, keep=keep);
  } # readUnitGroups()


  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Validate arguments
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Argument 'filename' and 'path':
  srcPathname <- Arguments$getReadablePathname(filename, path=path, mustExist=TRUE);

  # Argument 'verbose':
  verbose <- Arguments$getVerbose(verbose);
  if (verbose) {
    pushState(verbose);
    on.exit(popState(verbose));
  }


  ces <- NULL;

  verbose && enter(verbose, "Importing unit group summaries from APT tabular file");
  verbose && cat(verbose, "Pathname: ", srcPathname);

  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Open file & assert file format
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  con <- file(srcPathname, open="r");
  on.exit(close(con));

  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Read and validate header
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  header <- readAptHeader(con);
  verbose && cat(verbose, "File header:");
  verbose && str(verbose, header);

  chipType <- header[["chip_type"]];
  if (is.null(chipType)) {
    throw("File format error: No header element 'chip_type'.");
  }
  verbose && cat(verbose, "Chip type: ", chipType);

  cdf <- AffymetrixCdfFile$fromChipType(chipType);

  verbose && printf(verbose, "Monocell chip type: %s,monocell\n", chipType);
   # Get the ChipEffectFile class specific for this set
  clazz <- getChipEffectFileClass(static);
  monocellCdf <- clazz$createParamCdf(cdf);
  verbose && print(verbose, monocellCdf);


  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Infer data path
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  rootPath <- "plmData";
  chipType <- getChipType(cdf);
  currPath <- dirname(srcPathname);
  while(TRUE) {
    dataSetName <- basename(currPath);
    if (regexpr(chipType, dataSetName) == -1)
      break;
    currPath <- dirname(currPath);
  }

  outPath <- file.path(rootPath, dataSetName, chipType);
  outPath <- Arguments$getWritablePath(outPath);

  verbose && cat(verbose, "Output path: ", outPath);

  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Read column names
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  colNames <- readLines(con, n=1);
  sep <- "\t";

  colNames <- unlist(strsplit(colNames, split=sep));
  nbrOfColumns <- length(colNames);
  verbose && printf(verbose, "Column names [%d]: %s\n", nbrOfColumns,
                                           paste(colNames, collapse=", "));

  # Infer sample names
  sampleNames <- gsub("[.](cel|CEL)$", "", colNames[-1]);
  nbrOfSamples <- length(sampleNames);
  verbose && printf(verbose, "Sample names [%d]: %s\n", nbrOfSamples, paste(sampleNames, collapse=", "));


  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Prepare to read data
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Record the current file position
  skip <- attr(header, "nrows") + 1;
  dataOffset <- seek(con, rw="read");
  verbose && cat(verbose, "Data file offset: ", dataOffset);


  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Import each array
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  cells <- data <- NULL;

  verbose && enter(verbose, "Importing ", nbrOfSamples, " samples");
  for (kk in seq(length=nbrOfSamples)) {
    sampleName <- sampleNames[kk];
    verbose && enter(verbose, sprintf("Sample #%d (%s) of %d", 
                                            kk, sampleName, nbrOfSamples));

    # Create output filename
    filename <- sprintf("%s,chipEffects.cel", sampleName);
    pathname <- file.path(outPath, filename);
    verbose && cat(verbose, "Output pathname: ", pathname);

    if (skip && isFile(pathname)) {
      verbose && cat(verbose, "Already imported");
      verbose && exit(verbose);
      next;
    }


    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Infer cells from (unit, group) names in source file?
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if (is.null(cells)) {
      # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      # Retrieving (unit, group) from input file
      # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      key <- list(chipType=chipType, cmd=header$cmd);
      res <- loadCache(key);
      if (is.null(res)) {
        res <- readUnitGroups(con, cdf=monocellCdf, 
                           nbrOfColumns=nbrOfColumns, verbose=verbose);
        saveCache(res, key=key);
      }
      units <- res$units;
      groups <- res$groups;
      keep <- res$keep;
      rm(res);


      # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      # Getting (unit, group, cell) map
      # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      verbose && enter(verbose, "Getting CDF (unit,group,cell) map");
      ugcMap <- getUnitGroupCellMap(monocellCdf, units=unique(units), 
                                                    verbose=less(verbose));
      MAX.GROUP <- 4;
      key <- units*MAX.GROUP + groups;
      rm(units, groups);
      keyMap <- ugcMap[,"unit"]*MAX.GROUP + ugcMap[,"group"];
      rows <- match(key, keyMap);
      if (any(is.na(rows)))
        throw("Internal error: No existing (unit,group) pairs detected.");
      rm(key, keyMap);
      ugcMap <- ugcMap[rows,,drop=FALSE];
      verbose && str(verbose, ugcMap);
      rm(rows);
      cells <- ugcMap[,"cell"];
      rm(ugcMap);
      verbose && cat(verbose, "Number of cells: ", length(cells));
      verbose && exit(verbose);

      # Garbage collect
      gc <- gc();
      verbose && print(verbose, gc);
    }


    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Import data to tempory FileMatrix?
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Note, CEL files only hold floats.
    if (is.null(data)) {
      tmpFile <- tempfile("aroma.affymetrix.importFromAPT");
      if (isFile(tmpFile)) {
        data <- FileFloatMatrix(tmpFile);
      } else {
      colClasses <- c("NULL", rep("double", nbrOfSamples));
      data <- FileFloatMatrix$importFromTable(tmpFile, 
                         srcPathname=srcPathname, colClasses=colClasses, 
                            header=FALSE, skip=skip, nrows=length(cells), 
                                                  verbose=less(verbose));
      }
      verbose && print(verbose, data);

      # Garbage collect
      gc <- gc();
      verbose && print(verbose, gc);
    }


    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Import data to chip effect file
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    verbose && enter(verbose, "Retrieving chip-effect CEL file");
    verbose && cat(verbose, "Class: ", getName(clazz));
    if (isFile(pathname)) {
      cef <- clazz$fromFile(pathname, verbose=less(verbose));
    } else {
      cef <- clazz$fromDataFile(filename=filename, path=outPath, name=sampleName, cdf=monocellCdf, verbose=less(verbose));
    }
#    cef$combineAlleles <- TRUE;
    cef$mergeStrands <- FALSE;
    verbose && print(verbose, cef);
    verbose && exit(verbose);

    verbose && enter(verbose, "Storing imported chip effects");
    updateCel(pathname, indices=cells, intensities=data[,kk,drop=TRUE]);
    verbose && exit(verbose);

    # Garbage collect
    gc <- gc();
    verbose && print(verbose, gc);
    
    verbose && exit(verbose);
  }
  verbose && exit(verbose);

  # Clean up
  if (!is.null(data)) {
    close(data);
    tmpFile <- getPathname(data);
    rm(data);
    tmpFile <- getPathname(data);
    if (isFile(tmpFile)) {
      file.remove(tmpFile);
    }
  }

  # Define chip-effect set
  ces <- fromFiles(static, path=outPath);
  setCdf(ces, monocellCdf);

  verbose && exit(verbose);

  ces;
}, static=TRUE, private=TRUE)


############################################################################
# HISTORY:
# 2007-04-01
# o TO DO: Read the source file row by row and save as a temporary 
#   FileDoubleMatrix.  The extract from that one.
# o Created from CnChipEffectSet.importFromDChip.R.
############################################################################
