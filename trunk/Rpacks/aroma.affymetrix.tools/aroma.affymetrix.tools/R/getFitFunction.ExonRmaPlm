setMethodS3("getFitFunction","ExonRmaPlm", function (this,  ...,verbose = FALSE) {
    verbose <- Arguments$getVerbose(verbose)
    if (verbose) {
        pushState(verbose)
        on.exit(popState(verbose))
    }
    
    rmaModelMedianPolish<-function(y){
        if (is.null(dim(y))) {
            nbrOfArrays <- nbrOfArrays(getDataSet(this))
            return(list(theta = rep(NA, nbrOfArrays), sdTheta = rep(NA, 
                nbrOfArrays), thetaOutliers = rep(NA, nbrOfArrays), 
                phi = c(), sdPhi = c(), phiOutliers = c()))
        }
        if (length(dim(y)) != 2) {
            str(y)
            stop("Argument 'y' must have two dimensions: ", paste(dim(y), 
                collapse = "x"))
        }
        y <- y + shift
        y <- log(y, base = 2)
        I <- ncol(y)
        K <- nrow(y)
        mp <- medpolish(y, trace.iter=FALSE);
        fit <- list(Estimates=c(mp$overall+mp$col, mp$row), StdErrors=rep(0, length(c(mp$row,mp$col))));
      # Extract probe affinities and chip estimates
        J <- ncol(y);  # Number of arrays
        I <- nrow(y);  # Number of probes
        est <- fit$Estimates;
        se <- fit$StdErrors;
        # Chip effects
        beta <- est[1:J];
        # Probe affinities.  If only one probe, must have affinity=1 since
        # sum constraint => affinities sum to zero (on log scale)
        if (I==1) {
          alpha <- 0;
        } else {
          alpha <- est[(J+1):length(est)];
          alpha[length(alpha)] <- -sum(alpha[1:(length(alpha)-1)]);
        }
        theta <- 2^beta;
        phi <- 2^alpha;
        if (is.null(se)) {
          # For affyPLM v1.10.0 (2006-09-26) or older.
          sdTheta <- rep(1, J);
          sdPhi <- rep(1, I);
        } else {
          # For affyPLM v1.11.6 (2006-11-01) or newer.
          sdTheta <- 2^(se[1:J]);
          sdPhi <- 2^(se[(J+1):length(se)]);
        }
        thetaOutliers <- rep(FALSE, J);
        phiOutliers <- rep(FALSE, I);
        # Return data on the intensity scale
        list(theta=theta, sdTheta=sdTheta, thetaOutliers=thetaOutliers, 
             phi=phi, sdPhi=sdPhi, phiOutliers=phiOutliers);   
      } 
    attr(rmaModelMedianPolish, "name") <- "rmaModelMedianPolish"

    rmaModel<-getFitFunction.RmaPlm(this) #goes through the work to find the right function
    
    verbose && enter(verbose, "Creating Exon Array fit function")
    exonRmaModel <- function(y, psiCode=0, psiK=1.345, useMedianPolish=FALSE, medianPolishThreshold=100){
        if (is.null(dim(y))) {
            nbrOfArrays <- nbrOfArrays(getDataSet(this))
            return(list(theta = rep(NA, nbrOfArrays), sdTheta = rep(NA, 
                nbrOfArrays), thetaOutliers = rep(NA, nbrOfArrays), 
                phi = c(), sdPhi = c(), phiOutliers = c()))
        }
        if (length(dim(y)) != 2) {
            str(y)
            stop("Argument 'y' must have two dimensions: ", paste(dim(y), 
                collapse = "x"))
        }
        if (useMedianPolish) {
            nbrOfVariables <- dim(y)[1]+dim(y)[2]-1;
            if (nbrOfVariables > medianPolishThreshold) return(rmaModelMedianPolish(y))
            else return(rmaModel(y,psiCode=psiCode, psiK=psiK))
        } 
        else return(rmaModel(y,psiCode=psiCode, psiK=psiK))
    }
    attr(exonRmaModel, "name") <- "exonRmaModel"
    verbose && exit(verbose)
    exonRmaModel
}
)
