##########################################################################/**
# @RdocClass BamDataFile
#
# @title "The abstract BamDataFile class"
#
# \description{
#  @classhierarchy
#
#  A BamDataFile object represents a BAM file.
# }
#
# @synopsis
#
# \arguments{
#   \item{...}{Arguments passed to @see "R.filesets::GenericDataFile".}
# }
#
# \section{Fields and Methods}{
#  @allmethods "public"
# }
#
# @author "HB"
#
# \references{
#  [1] The SAM Format Specification Working Group,
#      \emph{The SAM Format Specification}, Sept 7, 2011.\cr
# }
#
# \seealso{
#   An object of this class is typically part of an
#   @see "BamDataSet".
# }
#*/###########################################################################
setConstructorS3("BamDataFile", function(...) {
  extend(GenericDataFile(...), c("BamDataFile", uses("AromaSeqDataFile")));
})


setMethodS3("as.character", "BamDataFile", function(x, ...) {
  this <- x;

  s <- NextMethod("as.character");

  s <- c(s, sprintf("Has index file (*.bai): %s", hasIndex(this)));
  s <- c(s, sprintf("Is sorted: %s", isSorted(this)));
  if (hasIndex(this)) {
    n <- nbrOfTargets(this);
    s <- c(s, sprintf("Number of targets: %s", n));
    len <- getTotalTargetLength(this);
    s <- c(s, sprintf("Total target length: %.3gMb (%.0f bases)", len/1e9, len));
    names <- getTargetNames(this);
    s <- c(s, sprintf("Targets: [%d] %s", n, hpaste(names)));

    counts <- getReadCounts(this);
    total <- sum(counts, na.rm=TRUE);
    s <- c(s, sprintf("Number of mapped reads: %d (%.1f%%) out of %d", counts[["mapped"]], 100*counts[["mapped"]]/total, total));
    s <- c(s, sprintf("Number of unmapped reads: %d (%.1f%%) out of %d", counts[["unmapped"]], 100*counts[["unmapped"]]/total, total));
  }
  s <- c(s, sprintf("Generated by: %s", getProgramString(this)));

  s;
}, protected=TRUE)


setMethodS3("buildIndex", "BamDataFile", function(this, ..., skip=!overwrite, overwrite=FALSE) {
  pathname <- getPathname(this);
  pathnameBAI <- sprintf("%s.bai", pathname);

  if (hasIndex(this)) {
    if (skip) {
      return(invisible(getIndexFile(this)));
    }
    if (!overwrite) {
      throw("Cannot build index file (*.bai). File already exists: ", pathnameBAI);
    }
  }

  pathnameT <- Rsamtools::indexBam(pathname);

  getIndexFile(this);
})


setMethodS3("getIndexFile", "BamDataFile", function(this, ...) {
  pathname <- getPathname(this);
  pathnameBAI <- sprintf("%s.bai", pathname);
  pathnameBAI <- Arguments$getReadablePathname(pathnameBAI, mustExist=FALSE);
  if (!isFile(pathnameBAI)) {
    return(NULL);
  }
  BamIndexDataFile(pathnameBAI);
})


setMethodS3("hasIndex", "BamDataFile", function(this, ...) {
  !is.null(getIndexFile(this));
})



setMethodS3("getIndexStats", "BamDataFile", function(this, ..., force=FALSE) {
  stats <- this$.idxStats;

  if (force || is.null(stats)) {
    pathname <- getPathname(this);
    if (!hasIndex(this)) {
      throw("Cannot get index statistics. Index does not exists: ", pathname);
    }
    # Quote pathnames
    bfr <- systemSamtools("idxstats", shQuote(pathname), stdout=TRUE, ...);
    bfr <- strsplit(bfr, split="\t", fixed=TRUE);
    seqName <- sapply(bfr, FUN=.subset, 1L);
    seqLength <- as.integer(sapply(bfr, FUN=.subset, 2L));
    countMapped <- as.numeric(sapply(bfr, FUN=.subset, 3L));
    countUnmapped <- as.numeric(sapply(bfr, FUN=.subset, 4L));

    # NOTE: samtools idxstats can return ridicolously(!) large read
    # counts.  Let's assume they are errors and set to NAs. /HB 2010-10-02
    countMapped[countMapped >= .Machine$integer.max] <- NA;
    countUnmapped[countUnmapped >= .Machine$integer.max] <- NA;
    countMapped <- as.integer(countMapped);
    countUnmapped <- as.integer(countUnmapped);

    stats <- data.frame(length=seqLength, mapped=countMapped, unmapped=countUnmapped);
    rownames(stats) <- seqName;
    this$.idxStats <- stats;
  }

  stats;
})


setMethodS3("getReadCounts", "BamDataFile", function(this, ...) {
  stats <- getIndexStats(this, ...);
  counts <- colSums(stats[,c("mapped", "unmapped")], na.rm=TRUE);
  counts;
})


setMethodS3("nbrOfReads", "BamDataFile", function(this, ...) {
  ## Does always work. /HB 2014-04-18
  ## Maybe 'samtools flagstat' is better?
  counts <- getReadCounts(this, ...);
  ## Very slow?!? /HB 2014-04-19
##  counts <- Rsamtools::countBam(getPathname(this))$records;
  sum(counts, na.rm=TRUE);
})

setMethodS3("nbrOfMappedReads", "BamDataFile", function(this, ...) {
  counts <- getReadCounts(this, ...);
  counts["mapped"];
})

setMethodS3("nbrOfUnmappedReads", "BamDataFile", function(this, ...) {
  counts <- getReadCounts(this, ...);
  counts["unmapped"];
})


# \details{
#   BAM headers typically contain an \code{"@HD VN:1.0 SO:<value>"} entry,
#   where \code{<value>} indicates whether the aligned reads are sorted
#   or not.  Unfortunately, this entry is neither enforced nor has it to
#   be correct [1,2].
#
#   Instead, we consider a BAM file to be sorted if and only if it has
#   an index file.  The rationale is that it is not possible to index
#   a BAM file unless it is sorted first.
# }
#
# \references{
#   [1] Question: is my BAM file sorted?, Biostar, 2011,
#   \url{http://www.biostars.org/post/show/5256/is-my-bam-file-sorted/}\cr
#   [2] Asking for suggestiona on samtools bug fixing, SEQanswers, 2010,
#   \url{http://seqanswers.com/forums/showthread.php?t=3739}\cr
# }
setMethodS3("isSorted", "BamDataFile", function(this, ...) {
  isTRUE(hasIndex(this));
})


# Argument '...' must be 2nd to match the generic base::sort() function.
setMethodS3("sort", "BamDataFile", function(x, ..., force=FALSE) {
  # To please R CMD check
  this <- x;

  # Nothing todo?
  if (!force && isSorted(this)) {
    return(this);
  }

  throw("Not yet implemented!");
})


setMethodS3("nbrOfSeqs", "BamDataFile", function(this, ...) {
  nbrOfTargets(this);
})

setMethodS3("getTargets", "BamDataFile", function(this, ...) {
  hdr <- getHeader(this);
  targets <- hdr$targets;
  targets;
})

setMethodS3("nbrOfTargets", "BamDataFile", function(this, ...) {
  length(getTargets(this));
})

setMethodS3("getTargetNames", "BamDataFile", function(this, ...) {
  names(getTargets(this));
})

setMethodS3("getTargetLengths", "BamDataFile", function(this, ...) {
  getTargets(this);
})

setMethodS3("getTotalTargetLength", "BamDataFile", function(this, ...) {
  sum(as.numeric(getTargets(this)));
})

setMethodS3("getHeader", "BamDataFile", function(this, force=FALSE, ...) {
  header <- this$.header;
  if (force || is.null(header)) {
    header <- readHeader(this, ...);
    this$.header <- header;
  }
  header;
})

setMethodS3("readHeader", "BamDataFile", function(this, ...) {
  pathname <- getPathname(this);
  bf <- Rsamtools::BamFile(pathname, index=character(0L));
  hdr <- Rsamtools::scanBamHeader(bf);
  hdr;
}, private=TRUE)


setMethodS3("getPrograms", "BamDataFile", function(this, ...) {
  hdr <- getHeader(this, ...);
  pgs <- hdr$text[names(hdr$text) == "@PG"];
  pgs <- lapply(pgs, FUN=function(pg) {
    pg <- trim(pg);
    pg <- strsplit(pg, split=":", fixed=TRUE);
    keys <- sapply(pg, FUN=function(x) x[1L]);
    values <- sapply(pg, FUN=function(x) x[-1L]);
    names(values) <- keys;
    values;
  })
  ids <- sapply(pgs, FUN=function(x) x[[1L]]);
  pgs <- lapply(pgs, FUN=function(x) x[-1L]);
  names(pgs) <- ids;
  pgs;
}, protected=TRUE)

setMethodS3("getProgram", "BamDataFile", function(this, ...) {
  pgList <- getPrograms(this, ...);
  if (length(pgList) >= 1L) {
    pgList <- pgList[[1L]];
  } else {
    pgList <- list();
  }
  pgList;
}, protected=TRUE)

setMethodS3("getProgramString", "BamDataFile", function(this, full=FALSE, ...) {
  pgs <- getPrograms(this, ...);
  res <- c();
  for (kk in seq_along(pgs)) {
    pg <- pgs[[kk]];
    name <- names(pgs)[kk];
    resK <- sprintf("(%d)", kk);

    # Program name
    pn <- c();
    if (!is.null(name)) pn <- c(pn, gsub("[.][0-9]+$", "", name));
    if (is.element("PN", names(pg))) pn <- c(pn, pg["PN"]);
    if (length(pn) == 2L) {
      pattern <- sprintf("^%s", pn[2]);
      pn[1] <- gsub(pattern, "", pn[1]);
      pn <- pn[nzchar(pn)];
    }
    pn <- paste(pn, collapse=" ");
    resK <- c(resK, pn);

    if (is.element("VN", names(pg))) resK <- c(resK, sprintf("v%s", pg["VN"]));
    if (full) {
      if (is.element("CL", names(pg))) resK <- c(resK, sprintf("(call: %s)", pg["CL"]));
      if (is.element("DS", names(pg))) resK <- c(resK, sprintf("[%s]", pg["DS"]));
    }
    resK <- paste(resK, collapse=" ");
    res <- c(res, resK);
  }
  res <- paste(res, collapse="; ");
  res;
}, protected=TRUE)


# \section{Read Groups (RG) specification}{
#   The RG fields populated are ID, SM, PL and LB, where
#   ID=identifier, SM=sample, PL=platform/technology, and
#   LB=library (DNA library prep identifier).
#   ID: Each RG must have a unique ID.
#   SM: Sample. Use pool name where a pool is being sequenced.
#   PM: Platform/technology used to produce the reads. Valid values:
#       CAPILLARY, HELICOS, ILLUMINA, IONTORRENT, LS454, PACBIO, and SOLID.
#   LB: Library.
#
#   Note that tools such as GATK (Broad Institute) requires read groups
#   'ID' and 'SM'. [3].
# }
#
# \references{
#  [1] The SAM Format Specification Working Group,
#      \emph{The SAM Format Specification}, Sept 7, 2011.\cr
#  [2] "What is '@RG ID' versus '@RG SM'"
#      \url{http://seqanswers.com/forums/showthread.php?t=9784}\cr
#  [3] Geraldine van der Auwera,
#      \emph{Collected FAQs about BAM files},
#      The Broad Institute, Aug 2012.
#      \url{http://gatkforums.broadinstitute.org/discussion/1317/collected-faqs-about-bam-files}\cr
# }
setMethodS3("getReadGroups", "BamDataFile", function(this, ...) {
  hdr <- getHeader(this, ...);
  SamReadGroup$byScanBamHeader(hdr, ...);
})

setMethodS3("getReadGroup", "BamDataFile", function(this, ...) {
  rgList <- getReadGroups(this, ...);
  if (length(rgList) >= 1L) {
    rgList <- rgList[[1L]];
  } else {
    rgList <- SamReadGroup();
  }
  rgList;
})


# @RdocMethod replaceAllReadGroups
# @title "Writes a new BAM file with all existing read groups replaced by one new read group"
#
# \description{
#   @get "title".
# }
#
# \arguments{
#  \item{sample}{Specifies the \code{SM} read group.}
#  \item{library}{Specifies the \code{LB} read group.}
#  \item{platform}{Specifies the \code{PL} read group.}
#  \item{platformUnit}{Specifies the \code{PU} read group.}
# }
setMethodS3("replaceAllReadGroups", "BamDataFile", function(this, rg="*", ..., validate=TRUE, skip=!overwrite, overwrite=FALSE, verbose=FALSE) {
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Validate arguments
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Argument 'rg':
  if (is.character(rg) && rg == "*") {
    rg <- SamReadGroup();
    keys <- names(asSamList(rg, drop=FALSE));
    for (key in keys) rg[[key]] <- "*";
  } else {
    rg <- Arguments$getInstanceOf(rg, "SamReadGroup");
  }

  # Argument 'verbose':
  verbose <- Arguments$getVerbose(verbose);
  if (verbose) {
    pushState(verbose);
    on.exit(popState(verbose));
  }

  verbose && enter(verbose, "Updating Read Groups");


  pathname <- getPathname(this);

  # Output pathname
  pathnameD <- gsub("[.]bam$", ",RG.bam", pathname);
  pathnameD <- Arguments$getWritablePathname(pathnameD, mustNotExist=(!skip && !overwrite));

  if (isFile(pathnameD)) {
    if (skip) {
      verbose && cat(verbose, "Already exists. Skipping.");
      bf <- newInstance(this, pathnameD);
      buildIndex(bf, skip=TRUE, verbose=less(verbose, 10));
      verbose && exit(verbose);
      return(bf);
    }
    if (!overwrite) {
      throw("Cannot replace SAM read groups. File already exists: ", pathnameD);
    }
  }


  verbose && cat(verbose, "Arguments:");
  verbose && print(verbose, rg);


  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Use default values from existing read groups of the input file?
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  rgList <- asSamList(rg);
  keep <- sapply(rgList, FUN=function(x) identical(x, "*"));
  keys <- names(rgList)[keep];
  if (length(keys) > 0L) {
    rgDefault <- getReadGroups(this);
    rgDefault <- Reduce(merge, rgDefault);
    # Sanity check
    stopifnot(inherits(rgDefault, "SamReadGroup"));

    for (key in keys) {
      rg[[key]] <- rgDefault[[key]];
    }
  } # for (key ...)


  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Validate
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  validate(rg);


  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Assert mandatory fields
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  rgList <- asSamList(rg);
  mandatory <- c("SM", "LB", "PL", "PU");
  missing <- setdiff(mandatory, names(rgList));
  if (length(missing)) {
    throw("Cannot write read groups. Mandatory fields are missing: ", hpaste(missing));
  }

  verbose && cat(verbose, "Arguments:");
  verbose && str(verbose, rgList);


  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Write new BAM file
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  args <- list("AddOrReplaceReadGroups", I=pathname, O=pathnameD);
  args <- c(args, asString(rg, fmtstr="RG%s=%s"));
  verbose && str(verbose, args);
  args$verbose <- less(verbose, 10);

  res <- do.call(systemPicard, args);
  status <- attr(res, "status"); if (is.null(status)) status <- 0L;
  verbose && cat(verbose, "Results:");
  verbose && str(verbose, res);
  verbose && cat(verbose, "Status:");
  verbose && str(verbose, status);

  bf <- newInstance(this, pathnameD);
  buildIndex(bf, overwrite=TRUE, verbose=less(verbose, 10));

  verbose && exit(verbose);

  bf;
}) # replaceAllReadGroups()


# See help("scanBam", package="Rsamtools") for definition of 'pos'.
setMethodS3("extractReadStartPositions", "BamDataFile", function(this, param=ScanBamParam(what=c("rname", "pos")), flag=scanBamFlag(isUnmappedQuery=FALSE, isDuplicate=FALSE), ..., verbose=FALSE) {
  require("Rsamtools") || throw("Package not loaded: Rsamtools");

  pathname <- getPathname(this);

  data <- scanBam(pathname, flag=flag, param=param, ...);
  data <- data[[1L]];
  data <- as.data.frame(data);
  data$rname <- as.character(data$rname);
  data;
})


setMethodS3("readDataFrame", "BamDataFile", function(this, fields=NULL, flag=scanBamFlag(isUnmappedQuery=FALSE, isDuplicate=FALSE), which=which, ..., verbose=FALSE) {
  require("Rsamtools") || throw("Package not loaded: Rsamtools");

  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Validate arguments
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Argument 'fields':
  knownFields <- c("qname", "flag", "rname", "strand", "pos", "qwidth", "mapq", "cigar", "mrnm", "mpos", "isize");
  if (is.null(fields)) {
    fields <- knownFields;
  }
  fields <- match.arg(fields, choices=knownFields, several.ok=TRUE);

  # Argument 'verbose':
  verbose <- Arguments$getVerbose(verbose);
  if (verbose) {
    pushState(verbose);
    on.exit(popState(verbose));
  }


  verbose && enter(verbose, "Reading data frame");

  pathname <- getPathname(this);
  verbose && cat(verbose, "Pathname: ", pathname);

  param <- ScanBamParam(what=fields, which=which);
  verbose && cat(verbose, "scanBam() parameters:");
  verbose && print(verbose, param);

  data <- scanBam(pathname, param=param, ...);

  # Sanity check
  stopifnot(is.list(data) && length(data) == 1L);
  data <- data[[1L]];
  stopifnot(is.list(data));
  verbose && str(verbose, data);

  verbose && enter(verbose, "Coercing list to data frame");
  # Sanity check
  ns <- sapply(data, FUN=length);
  stopifnot(all(ns == ns[1L]));

  data <- as.data.frame(data, stringsAsFactors=TRUE);
  verbose && str(verbose, data);
  verbose && exit(verbose);

  verbose && exit(verbose);

  data;
})


setMethodS3("readReadPositions", "BamDataFile", function(this, ..., flag=scanBamFlag(isUnmappedQuery=FALSE, isDuplicate=FALSE), verbose=FALSE) {
  require("Rsamtools") || throw("Package not loaded: Rsamtools");

  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Validate arguments
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Argument 'verbose':
  verbose <- Arguments$getVerbose(verbose);
  if (verbose) {
    pushState(verbose);
    on.exit(popState(verbose));
  }

  verbose && enter(verbose, "Reading (rname,pos)");

  verbose && cat(verbose, "scanBam() flags:");
  verbose && print(verbose, flag);

  data <- readDataFrame(this, fields=c("rname", "pos"), flag=flag, ..., verbose=less(verbose, 5));

  verbose && exit(verbose);

  data;
}) # readReadPositions()


###########################################################################/**
# @RdocMethod validate
# @alias validate.SamDataFile
#
# @title "Validates a BAM (or SAM) file"
#
# \description{
#   @get "title".
# }
#
# @synopsis
#
# \arguments{
#  \item{method}{A @character string specifying which validation method to use.}
#  \item{...}{Additional arguments passed to the internal validation method.}
#  \item{verbose}{See @see "R.utils::Verbose".}
# }
#
# \value{
#   Returns (invisibly) what the internal validation method returns,
#   or throws an exception if an error is detected.
# }
#
# \seealso{
#   Internally \code{picardValidateSamFile()} is used.
# }
#
# @author "HB"
#
# @keyword internal
#*/###########################################################################
setMethodS3("validate", "BamDataFile", function(this, method=c("picard"), ..., verbose=FALSE) {
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Validate arguments
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Argument 'method':
  method <- match.arg(method);

  # Argument 'verbose':
  verbose <- Arguments$getVerbose(verbose);
  if (verbose) {
    pushState(verbose);
    on.exit(popState(verbose));
  }

  verbose && enter(verbose, sprintf("Validating %s", class(this)[1L]));
  verbose && cat(verbose, "Validation method: ", method);

  if (method == "picard") {
    stopifnot(isCapableOf(aroma.seq, "picard"));
    res <- picardValidateSamFile(getPathname(this), ..., verbose=verbose);
  }

  verbose && exit(verbose);

  invisible(res);
}, protected=TRUE)



setMethodS3("writeSample", "BamDataFile", function(this, pathname, n, seed=NULL, ..., verbose=FALSE) {
  require("Rsamtools") || throw("Package not loaded: Rsamtools");

  # Argument 'pathname':
  pathname <- Arguments$getWritablePathname(pathname, mustNotExist=TRUE);

  # Argument 'n':
  n <- Arguments$getInteger(n, range=c(1,Inf));
  nMax <- nbrOfReads(this);
  if (n > nMax) {
    throw("Requested more reads than available. Cannot sample with replacement: ", n, " > ", nMax);
  }

  # Argument 'seed':
  if (!is.null(seed)) seed <- Arguments$getInteger(seed);

  # Argument 'verbose':
  verbose <- Arguments$getVerbose(verbose);
  if (verbose) {
    pushState(verbose);
    on.exit(popState(verbose));
  }


  verbose && enter(verbose, sprintf("Writing sample of %s", class(this)[1L]));
  verbose && print(verbose, this);
  verbose && cat(verbose, "Sample size: ", n);
  verbose && cat(verbose, "seed: ", seed);

  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Set the random seed
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  if (!is.null(seed)) {
    verbose && enter(verbose, "Setting (temporary) random seed");
    oldRandomSeed <- NULL;
    if (exists(".Random.seed", mode="integer")) {
      oldRandomSeed <- get(".Random.seed", mode="integer");
    }
    on.exit({
      if (!is.null(oldRandomSeed)) {
        .Random.seed <<- oldRandomSeed;
      }
    }, add=TRUE);
    verbose && cat(verbose, "The random seed will be reset to its original state afterward.");
    verbose && cat(verbose, "Seed: ", seed);
    set.seed(seed);
    verbose && exit(verbose);
  }

  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Sample what to keep
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  verbose && enter(verbose, "Sample read indexed to keep");
  progress <- isVisible(verbose);
  yieldSize <- 100e3;

  if (n < nMax) {
    keep <- logical(length=nMax);
    keep[sample(nMax, size=n, replace=FALSE)] <- TRUE;
    verbose && print(verbose, table(keep));

    # Offset
    offset <- 0L;

    cprogress <- 0L;
    dprogress <- ceiling(nMax/yieldSize/100);

    # TODO: Added ram/buffer size option. /HB 2013-07-01
    filter <- FilterRules(list(sampler=function(x) {
      # Display progress?
      if (progress) {
        if (cprogress %% dprogress == 0L) message(".", appendLF=FALSE);
      }

      n <- nrow(x);

      # Nothing to do?
      if (n == 0L) return(logical(0L));

      # Available indices
      res <- keep[offset + seq_len(n)];

      # Sanity check
      stopifnot(length(res) == n);

      # Update offset
      offset <<- offset + n;

      if (progress) {
        cprogress <<- cprogress + 1L;
        if (cprogress == 100L) message(". [100%]", appendLF=TRUE);
      }

      res;
    }))
  } else {
    verbose && cat(verbose, "Nothing to filter; keeping all reads");
    # Nothing to filter; keep everything
    filter <- NULL;
  }
  verbose && exit(verbose);

  verbose && enter(verbose, "Filtering");

  # Input file
  pathnameBAM <- getPathname(this);
  verbose && enter(verbose, "");

  # Index file
  pathnameI <- sprintf("%s.bai", pathname);

  # Write to temporary file
  pathnameT <- pushTemporaryFile(pathname);
  pathnameIT <- sprintf("%s.bai", pathnameT);

  bam <- BamFile(pathnameBAM, yieldSize=yieldSize);
  pathname2 <- filterBam(bam, destination=pathnameT, filter=filter, indexDestination=TRUE);
  verbose && cat(verbose, "Created: ", pathname2);

  bam2 <- newInstance(this, pathname2);
  stopifnot(nbrOfReads(bam2) == n);

  # Undo temporary files
  file.rename(pathnameIT, pathnameI);
  pathname <- popTemporaryFile(pathnameT);

  verbose && exit(verbose);

  bam <- newInstance(this, pathname);
  verbose && print(verbose, bam);

  verbose && exit(verbose);

  bam;
}, protected=TRUE)



############################################################################
# HISTORY:
# 2014-04-19
# o Now getProgramString() for BamDataFile returns information on all
#   programs used, not just the first one.  By default, it no longer
#   reports on the full calls. It also does a better job on presenting
#   and cleaning up the software names.
# 2014-04-18
# o Added writeSample() for BamDataFile utilizing Rsamtools::filterBam().
# 2014-03-09
# o BUG FIX: getIndexStats() for BamDataFile would not work if pathname
#   had a space or other symbols causing it to be split up.
# 2014-03-07
# o RELAXATION: readHeader() for BamDataFile no longer require that
#   the BAM file is indexed.
# o Now as.character()/print() for BamDataFile reports on by which software
#   (and how) the BAM file was created, if the @PG SAM header is available.
# 2012-10-30
# o Added validate() for BamDataFile.
# 2012-10-10
# o Added argument 'which' to readDataFrame() for BamDataFile.
# 2012-10-02
# o Added readReadPositions() for BamDataFile.
# o Added readDataFrame() for BamDataFile.
# o Added getIndexStats() for BamDataFile.
# o Now buildIndex() for BamDataFile returns a BamIndexDataFile.
# o Added getIndexFile() for BamDataFile.
# 2012-06-28
# o Added getReadGroups() and replaceAllReadGroups() and buildIndex().
# o Created.
############################################################################
