%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Authors: Henrik Bengtsson, hb@stat.berkeley.edu
%          Pierre Neuvial, pierre@stat.berkeley.edu
% Created on: 2009-02-23
% Modified on: 2012-03-15
%
<%--
  Usage:
  pathname <- "OrtizM_etal_2011-CalMaTe,SupplementaryNote,ROC.tex.rsp";
  rsp(pathname, force=TRUE, verbose=-5);
 --%>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

%=====================================================================
% Analysis setup
%=====================================================================
<%
verbose && enter(verbose, "Setup");

# Loading include files
sourceDirectory("R/");


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Graphical settings
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
devOptions("png", width=840);
devOptions("pdf", width=8.4);
setOption("devEval/args/path", figPath);
setOption("devEval/args/force", FALSE);
toFig <- toPNG;

pch <- "."; cex <- 2.5;

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Misc.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
pmTag <- "@plusOrMinus@";

postProcessing <- names(dataList);
postProcessing <- gsub("^[^,]*,*", "", postProcessing);
postProcessing <- gsub("^XY(|,)", "", postProcessing); # AD HOC
postProcessing <- postProcessing[nchar(postProcessing) > 0];
postProcessingStr <- hpaste(postProcessing, lastCollapse=" as well as ");


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Analysis settings
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
probeTypes <- c("all SNPs", "heterozygous SNPs")[2];

# Number of bootstrap iterations (use B <- 1 for no bootstrapping)
B <- 100;
output <- c("statistic", "p.value")[1];

fixedNbPointsAcrossMethods <- c(TRUE, FALSE)[1];
fixedNbPointsAcrossRegions <- c(TRUE, FALSE)[2];

## a combination not implemented yet:
if (!fixedNbPointsAcrossMethods) {
  if (fixedNbPointsAcrossRegions) {
    throw("Not supported yet: fixedNbPointsAcrossRegions == TRUE when fixedNbPointsAcrossMethods == FALSE.");
  }
  B <- 1;
}

verbose && exit(verbose);
%>


<%
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Document settings
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
title <- sprintf("CalMaTe Supplementary Note: Assessment of %s based on tumor/normal pair %s in the %s %s data set %s", hpaste(postProcessing, lastCollapse=" and "), sampleName, platform, toLatex(chipType), dataSetF);
authors <- "Maria Ortiz-Estevez, Ander Aramburu, Henrik Bengtsson, Pierre Neuvial, Angel Rubio";
%>



%=====================================================================
% LaTeX setup
%=====================================================================
%\documentclass[a4paper,twoside,10pt]{article}
%\documentclass[twoside,12pt]{report} 
\documentclass[10pt]{report} 
\usepackage{graphicx}
\usepackage{grffile} % Allows for multiple dots in figure filenames
\usepackage{a4wide}
\usepackage{xspace}
\usepackage{amsmath} 
\usepackage{natbib}
\usepackage{subfig}  % \subfloat[<title>]{} 
\captionsetup{position=top}

\usepackage{listings}
\lstset{%
%  language=R,
%  basicstyle=\ttfamily,
  columns=flexible,
  breaklines=true
}

\usepackage{titlesec}
\titleformat{\chapter}
  {\normalfont\Large\bfseries}{\thechapter}{1em}{}
\titlespacing*{\chapter}{0pt}{3.5ex plus 1ex minus .2ex}{2.3ex plus .2ex}

\addtolength{\oddsidemargin}{-5mm}
\addtolength{\textwidth}{15mm}
\addtolength{\topmargin}{-15mm}
\addtolength{\textheight}{10mm}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE,RO]{\thepage}
% 'twopage':
%%\fancyhead[RE]{\textit{\nouppercase{\leftmark}}}
%%\fancyhead[LO]{\textit{\nouppercase{\rightmark}}}
\fancyhead[LO]{\textit{\nouppercase{\leftmark}}}

\renewcommand{\topfraction}{1.00}   % max fraction of floats at top
\renewcommand{\bottomfraction}{1.0} % max fraction of floats at bottom
\renewcommand{\textfraction}{0.00}

% The search path (must end with a slash, be within curly brackets,
% and separated by commas)
% where to find graphics files
\graphicspath{{<%=figPath%>/}}
\DeclareGraphicsRule{.eps.gz}{eps}{.eps.bb}{`gunzip -c #1}

\newcommand{\pkg}[1]{\textsl{#1}\xspace}
\newcommand{\trackWidth}{<%=trackWidth%>\textwidth}

% Other notation
\newcommand{\TCN}{\ensuremath{\textnormal{TCN}}\xspace}
\newcommand{\BAF}{\ensuremath{\textnormal{BAF}}\xspace}
\newcommand{\DoH}{\ensuremath{\textnormal{DH}}\xspace} 

\title{<%=title%>}
\author{<%=authors%>}

\begin{document}
\maketitle

\tableofcontents

\clearpage

%=====================================================================
% Introduction
%=====================================================================
\chapter{Introduction}
In order to formally evaluate the influence of CalMaTe on signal to noise ratio, we have used receiver operating characteristic (ROC) analysis on several known change points.  ROC analysis was performed as described in~\citet{BengtssonH_etal_2009b, BengtssonH_etal_2010}.  We refer to these papers for a thorough description of this report.  
Here, we explain in detail how this evaluation is carried out a specific tumor sample: <%=sampleName%>.
We chose the same change points as those used for the evaluation of the TumorBoost method~\citep{BengtssonH_etal_2010} in order to facilitate comparison between CalMaTe and TumorBoost, and interpretation of the results.  
The evaluation is done at set of change points corresponding to common types of copy number state transitions, and at one region with no change point (negative control) as summarized in Table~\ref{tblRegions} (also \citet[Table~1]{BengtssonH_etal_2010}).



%=====================================================================
% Description of data set studied
%=====================================================================
\section{Data}

\subsection{Data set}
The evaluation in this report is based on the tumor/normal pair for individual <%=sampleName%> in the data set <%=dataSetF%>. 


\subsection{List of change points}
\label{secListOfChangePoints}
For this data set, we have selected a few regions for which one can safely assume that there exists a single copy number change point. By definition, each change point separates two sets of genomic loci such that the true Total Copy Number (TCN) and Decrease in Heterozygosity (DH) is the same within one set of loci but differs between the two sets.  These regions were selected by visual inspection.  For each region we chose a large enough safety margin to make our evaluation independent of the uncertainty on the true location of the change point.

\begin{table}[htb]
\begin{center}
\begin{tabular}{c|c|c|c|c|c}
Chr & Region & Change point & Margin & Before & After \\
\hline
<%
for (region in regionsList) { 
  chr <- region$chromosome;
  reg <- region$region/1e6;
  cp <- region$params$cp[1];
  delta <- region$params$cp[2];
  regionLabels <- getRegionLabels(region$params$s);
%><%=chr%> & <%=reg[1]%>-<%=reg[2]%> & <%=cp%> & <%=delta%> & <%=regionLabels[1]%> & <%=regionLabels[2]%> \\ \hline
<% } # for (region ...) %>
<% rm(chr, reg, cp, delta, regionLabels, region); %>%
\end{tabular}
\end{center}
\caption{Regions in <%=sampleName%> used for the evaluation and that each contain a single changepoint. 
The last region is a negative control.
All positions and lengths are in units of Mb.
}
\label{tblRegions}
\end{table}


\section{Methods}

\subsection{Preprocessing method}
The data was generated on the <%=platform%> <%=toLatex(chipType)%> chip type.  
<% if (platform == "Affymetrix") { %>
  There is one CEL file per hybridization.
  Each CEL file was preprocessed separately using CRMAv2~\citep{BengtssonH_etal_2009b}, without relying neither on reference samples nor prior estimates.
<% } %>
<% if (platform == "Illumina") { %>
  The raw data was preprocessed using using the Illumina BeadStudio software.
<% } %>


\subsection{Postprocessing methods}
The result of the above preprocessing method are estimates of total copy numbers (TCNs) and allele B fractions (BAFs).
The (TCN,BAF) signals are then postprocessed by <%=postProcessingStr%>.
<% if (is.element("TumorBoost", postProcessing)) { %>
Because TumorBoost models each tumor-normal pair independently, it can be applied to the studied pair without the need for reference samples~\citep{BengtssonH_etal_2010}.
<% } %>
<% if (is.element("CalMaTe", postProcessing)) { %>
The CalMaTe method is a multi-array method, which estimates SNP effects from a set of reference samples, and then correct all samples based on these estimates.  For details on the reference set used, see descriptions elsewhere.
<% } %>

\subsection{Identifying heterozygous SNPs}
When evaluating the power to detect a change point using the BAFs, we identify the heterozyous SNPs from the matched normal to calculate the Decrease of Heterozygousity (DH) signals.
We use a naive genotyping algorithm~\citep{BengtssonH_etal_2010} to identify the heterozygous SNPs.  For each method, the genotypes are called based on the BAFs in generates.



\subsection{Stratification on genotype confidence scores}
In~\citet{BengtssonH_etal_2010} it was shown that it is possible to slightly improve the discrimination power in DH by filtering out SNPs for which the genotype confidence scores are low.  In this report we choose not do to this, i.e. all heterozygous SNPs are used.


%=====================================================================
% Description of change points studied
%=====================================================================
\subsection{Evaluation}
Each change point (except for the negative control) corresponds to a real change in both TCN and BAF, between what we call a "negative" state (defined as the closest to TCN=2) and a "positive" state (the other one).  We focus on a genomic region surrounding the change point.  Consider a threshold value $\tau$.  For BAF signals, we calculate the Decrease in Heterozygosity (DH) defined for each heterozygous SNP $j$ as $\DoH_j = 2|\BAF_j-1/2|$.  DH is appropriate for evaluation purposes because contrary for BAF its distribution only has one mode, as discussed e.g. in \citet{BengtssonH_etal_2010}.  A SNP $j$ is then classified as "positive" if $DH_j \geq \tau$, and as "negative" otherwise, and we report the true-positive rate (TPR) and the true-negative rate (TNR) in the region.  Repeating this for each possible value of $\tau$, we build a ROC curve for DH by plotting TPR against TNR in the genomic region.  A ROC curve can be built along similar lines for TCN, where a locus $j$ is classified as "positive" if $\TCN_j \geq \tau$ if the positive state has greater TCN than the negative state, and $\TCN_j \leq \tau$ otherwise.   Using this strategy, we plot a TCN and a DH ROC curve for each method to be compared, e.g. genomic signals before and after CalMaTe. 
<%
nms <- names(dataList);
descs <- character(length(nms));
descs[nms == dataSetTags] <- sprintf("%s preprocessed signals without postprocessing", dataSetTags);
descs[regexpr("TumorBoost", nms) != -1] <- sprintf("%s preprocessed signals with TumorBoost postprocessing", dataSetTags);
descs[regexpr("CalMaTe", nms) != -1] <- sprintf("%s preprocessed signals with CalMaTe postprocessing", dataSetTags);
%>
Specifically, we compare the following sets of data:
\begin{enumerate}
<% for (ii in seq(along=nms)) {%>%
  \item \textbf{``<%=nms[ii]%>"}: <%=descs[ii]%>. 
<% } ## for (ii in ... ) %>%
\end{enumerate}
The assessment is based on ROC analysis at the full resolution as well 
as various smoothed resolution with bin sizes $h=\{<%=hpaste(binWidths * ifelse(byCount,1,1e-3))%>\}$<%=if (!byCount) "~kb"%>.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% BEGIN Regions of interest
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<% for (region in regionsList) { %>
<%
# Subset by region
signalList <- with(region, {
  lapply(dataList, FUN=function(data) {
    extractRegion(data, region=region, chromosome=chromosome);
  })
});

# Attach "truth"
truth <- makeTruth(region);
signalList <- lapply(signalList, FUN=function(data) {
  data$state <- truth;
  data;
});
%>
\clearpage
\chapter{Region: <%=gsub(",cp.*", "", region$src)%>}

<%
enter(verbose, "abs(fracB-1/2)");

pcns <- NULL;

nms <- names(signalList);
print(nms);


# Balance the left and the right regions?
if (byCount) {
  minNbrOfPoints <- min(sapply(signalList, FUN=function(signals) {
    min(table(signals$state));
  }));
  # Sanity check
  stopifnot(is.finite(minNbrOfPoints));
  if (is.null(fixedNbrOfPoints)) {
    binWidths <- binWidths * fixedNbrOfPoints/minNbrOfPoints;
    minNbrOfPoints <- fixedNbrOfPoints;
  }
  if (!is.null(fixedSeed)) {
    set.seed(fixedSeed);
  }    
  signalList <- lapply(signalList, FUN=function(signals) {
    getBalancedRegions(signals, minNbrOfPoints, replace=TRUE);
  });
} # if (byCount)

nbrOfSets <- length(signalList);
nms <- names(signalList);
%>


<% if (plotTracks) { %>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN FIGURE: eval tracks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<%
rhoLim <- c(0, 1);
rhoLab <- expression(rho);
rhoLabT <- expression(tilde(rho));

cnLim <- c(0, 5);
cnLab <- expression(C == 2*(theta[T]/theta[N]));
cnLab <- "C";

xRange <- range(sapply(signalList, FUN=xRange));
states <- signalList[[1]]$state;
ustates <- sort(unique(states));
xlim <- xRange * 1e-6;
cp <- region$params$cp;
s <- region$params$s;
xs <- cp["position"]+c(-1,+1)*cp["delta"];
%>

<% whats <- c("TCN", "DH"); %>
\section{<%=paste(whats, collapse=" and ")%> tracks}
<% for (what in whats) { %>
<%
figList <- list();
for (kk in seq(along=signalList)) {
  name <- names(signalList)[kk];
    signal <- signalList[[kk]];

    whatStr <- what;

    addStateLabels <- FALSE;
      addStateLabels <- TRUE;
    if (what == "TCN") {
      ylim <- cnLim;
      ylab <- cnLab;
      field <- "C";
    } else if (what == "DH") {
      ylim <- rhoLim;
      ylab <- rhoLab;
      field <- "rho";
      # Keep only heterozygous SNPs (where DH is defined)
      signal <- subset(signal, isHet);
    }

    # Identify the states
    states <- signal$state;
    tbl <- table(signal$state);
    names(tbl) <- getRegionLabels(names(tbl));

    # Color annotations
    col <- stateToColor(states, colorMap=fullResColorMap);

    if (addBinTrack) {
      signalS <- binnedSmoothingByField(signal, field="state", fields=field, from=xRange[1], to=xRange[2], by=binWidthS, FUN=binFUN, byCount=byCount);
      colS <- stateToColor(signalS$state, colorMap=smoothedColorMap);
    }


    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    # Plot along genome
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    figName <- toFig(region$label, tags=c(what, "track", name), aspectRatio=0.26, {
      par(mar=c(1.2,2,0.6,0.3)+0.2, mgp=c(1.2,0.3,0), tcl=-0.3, cex=cex, cex.axis=0.7);

      plot(signal, field=field, pch=pch, cex=cex, col=col, xlim=xlim, ylim=ylim, ylab=ylab);

      # Add state labels?
      if (addStateLabels) {
        stext(side=3, pos=0, line=0, cex=0.6*cex, padj=0.5, names(tbl[1]));
        stext(side=3, pos=1, line=0, cex=0.6*cex, padj=0.5, names(tbl[2]));
      }
 
      # Highlight the state called
      ys <- par("usr")[3:4];
      dy <- 0.04*diff(ys);
      if (s[1] != 0) {
        rect(xlim[1],ys[1],xs[1],ys[1]+dy, col="#999999");
      } else {
        rect(xs[2],ys[1],xlim[2],ys[1]+dy, col="#999999");
      }

      # Highlight the safety zone
      rect(xs[1],ys[1],xs[2],ys[2], density=10, col="#999999");
      rm(ys, dy);
  
      # Add smoothed track?
      if (addBinTrack) {
        lines(signalS, field=field, lty=1, lwd=2, col="white");
        points(signalS, field=field, pch=19, cex=0.7, col="white");
        lines(signalS, field=field, lty=3, lwd=1);
        points(signalS, field=field, pch=19, cex=0.5, col=colS);
      }

      # Display SD estimate
      if (addSdEst) {
        sd <- estimateStandardDeviation(signal, field=field);
        sd <- sprintf("%.3g", sd);
        sd <- substitute(sigma[Delta]==x, list(x=sd));
        stext(side=4, pos=1, line=-0.2, cex=0.4*cex, sd);
      }

      if (addCounts) {
        stext(side=1, pos=0, line=-0.2, cex=0.4*cex, sprintf("n=%d", tbl[1]));
        stext(side=1, pos=1, line=-0.2, cex=0.4*cex, sprintf("n=%d", tbl[2]));
      }
    }) # toPNG()
    figList[[kk]] <- figName;
} # for (kk ...)
%>

\begin{figure}[htb]
 \begin{center}
 <% for (figName in figList) { %>%
  <% 
    label <- gsub(".*,track,", "", figName);
  %>%
  \subfloat[<%=label%>.]{
   \resizebox{\trackWidth}{!}{\includegraphics{<%=figName%>}}
  }\\
  <% } %>
 \end{center}
 \caption{
  <%=what%>s of the different methods for region <%=region$src%>.
  <% if (what == "DH") { %> DHs are only defined for SNPs that are genotyped to be heterozygous based on data from the corresponding method. <% } %>%
  The sets of loci to the left and the right belong to two different copy-number states, separated by a change points.  The exact location of the change point is unknown, except that it is located within safety margin (shaded with diagonal lines).
  One of the copy-number states is referred to as the "negative" state ('<%=names(tbl)[1]%>') and the other as the "positive" state ('<%=names(tbl)[2]%>'), where the latter are highlighted with a solid bar beneath.
<%--
  There are <%=tbl[1]%> loci of state <%=names(tbl)[1]%> ("negatives") and <%=tbl[2]%> loci of state <%=names(tbl)[2]%> ("positives"), where the latter are highlighted with a solid bar beneath.  In total <%=tbl[3]%> loci within the safety margin were excluded.
--%>
  Legend: Full resolution <%=what%>s are displayed in black and smoothed (bin width <%=sprintf("%g kb", binWidthS/1e3)%>) ones in blue.  Loci within the safety margin are displayed in gray and excluded from all analysis.
 }
 \label{fig<%=figName%>}
\end{figure}
<% } # for (what ...) %>


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END FIGURE: eval tracks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<% } ## if (plotTracks) { %>

\clearpage
<% whats <- c("TCN", "BAF"); %>
\section{<%=paste(whats, collapse=" and ")%> signal density plots}
<%
verbose && enter(verbose, "Plotting densities");
%>
<% for (what in whats) { %>
<%
  platform <- getPlatform(signalList[[1]]);
  if (what == "TCN") {
    field <- "C";
    xlab <- expression(C);
    xlim <- c(-0.2,0.2) + cnLim;
    ats <- NULL;
    if (platform == "Affymetrix") {
      ylim <- c(0,1.4);
      adjust <- 0.5;
    } else {
      ylim <- c(0,3.0);
      adjust <- 0.5;
    }
  } else if (what == "BAF") {
    field <- "betaT";
    xlab <- expression(beta[T]);
    xlim <- c(-0.2,0.2) + rhoLim;
    ats <- c(0, 1/2, 1);
    if (platform == "Affymetrix") {
      ylim <- c(0,4.0);
      adjust <- 0.3;
    } else {
      ylim <- c(0,6.5);
      adjust <- 0.3;
    }
  }
%>

<%
tbl <- sapply(signalList, FUN=getNbLociPerState);
if (byCount) {
  # Should be balanced
  stopifnot(all(rowSds(tbl) == 0));
}
tbl <- tbl[,1, drop=TRUE];
%>

\begin{figure}[htb]
 \begin{center}
<% for (ss in seq(along=ustates)) { %>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% BEGIN Figure: Signal densities for state <%=ustates[ss]%>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
  \subfloat[<%=names(tbl)[ss]%>.]{
    <%
    figName <- toFig(region$label, tags=c(what, "density", sprintf("state=%s", ustates[ss])), aspectRatio=0.4, {
      par(mar=c(2.7,0.2,1.2,0.2)+0.1, mgp=c(1.4,0.3,0), tcl=-0.3, cex=cex, cex.axis=1.2, cex.lab=1.2);
      signalListS <- lapply(signalList, FUN=function(signal) {
        subset(signal, state == ustates[ss]);
      });
      Y <- sapply(signalListS, FUN=function(signal) signal[[field]]);
      methods <- names(signalListS);
      colsT <- getMethodColor(methods, what=what);
      ltysT <- getMethodLineType(methods, what=what);
      plotDensity(Y, col=colsT, lty=ltysT, lwd=6, adjust=adjust, xlim=xlim, ylim=ylim, xlab=xlab, ylab=NULL, axes=FALSE);
      axis(side=1, labels=FALSE, col.ticks=NA);
      axis(side=1, at=ats);
      if (addStateLabels) {
        stext(side=3, pos=0.5, line=0, margin=c(0.2,0), cex=cex, names(tbl)[ss]);
      }
    }) # toFig()
    %>%
   \resizebox{0.44\textwidth}{!}{\includegraphics{<%=figName%>}}%
  } % \subfloat{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% END Figure: Signal densities for state <%=ustates[ss]%>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
<%  } # for (ss ...) %>
 \end{center}
 \caption{
  Densities of <%=what%>s for region <%=region$src%>.
  Legend: <%=getMethodLegends(names(signalList), what=what, collapse=TRUE)%>.
 }
 \label{fig<%=fullname(region$label, tags=c(what, "density"))%>}
\end{figure}

<% verbose && exit(verbose); %>

<% } # for (what ...) %>





\clearpage
\section{Tumor versus normal BAF plots}
<%
verbose && enter(verbose, "Plotting (beta_N, beta_T)")
%>
<%
  xScale <- 1e-6;
  cp <- region$params$cp;
  s <- region$params$s;
 
  xlab <- expression(beta[N] == theta[B,N]/theta[N]);
  ylab <- expression(beta[T] == theta[B,T]/theta[T]);
  xlab <- expression(beta[N]);
  ylab <- expression(beta[T]);
  lim <- c(-0.1,1.1);

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
# Plot $(\beta_N, \beta_T)$
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
%>
<%
tbl <- sapply(signalList, FUN=getNbLociPerState);
if (byCount) {
  stopifnot(all(rowSds(tbl) == 0));
}
tbl <- tbl[,1, drop=TRUE];
%>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% BEGIN Figure: (betaN, betaT) for each state separately: <%=names(signalList)[kk]%>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\begin{figure}[htb]
  \begin{center}
<% methods <- names(signalList); %>
<%  for (kk in seq(along=signalList)) { %>
  \subfloat[<%=methods[kk]%>.]{
<%
    name <- names(signalList)[kk];
    signalsKK <- signalList[[kk]];
    signalsKK <- subset(signalsKK, isSNP);

    for (ss in seq(along=ustates)) {
      signals <- subset(signalsKK, state == ustates[ss]);

      betaT <- signals$betaT;
      betaN <- signals$betaN;

      # Homozygous & heterozygous color scheme
      isHet <- signals$isHet;
      col <- rep(homCol, times=nbrOfLoci(signals));
      col[isHet] <- hetCol;

      figName <- toFig(region$label, tags=c("betaNvsBetaT", what, name, sprintf("state=%s", ustates[ss])), {
        par(mar=c(2.7,2.6,1.2,0)+0.1, mgp=c(1.4,0.3,0), tcl=-0.3, cex=cex, cex.axis=1.2, cex.lab=1.2);
        plot(NA, xlim=lim, ylim=lim, xlab=xlab, ylab=ylab, axes=FALSE);
        axis(side=1, at=c(0,1/2,1));
        axis(side=2, at=c(0,1/2,1));

        if (addDiagHorizLines) {	
          if (is.element(name, c("raw", "CalMaTe"))) {
            ys <- seq(from=0.0, to=1.0, by=0.1);
            for (y in ys) {
              lines(x=c(0,1-y), y=c(y,1), col="#999999", lty=1, lwd=1);
              lines(x=c(1,y), y=c(1-y,0), col="#999999", lty=1, lwd=1);
            }
          } else { 
            ys <- seq(from=0.0, to=1.0, by=0.1);
            for (y in ys) {
              lines(x=c(0,1), y=c(y,y), col="#999999", lty=1, lwd=1);
            }
          }
	}

        ## boxes
        z <- 0:2/2;
        a <- rep(min(z), length(z));
        b <- rep(max(z), length(z));
        segments(a, z, b, z, col="#999999", lty=2);
        segments(z, a, z, b, col="#999999", lty=2);

        points(betaN, betaT, pch=pch, col=col, cex=cex);
        
        nm <- names(tbl)[ss];
        stext(side=3, pos=0, line=-0.3, cex=cex, nm);
    }) # toFig()
      %>%
      \resizebox{0.34\textwidth}{!}{\includegraphics{<%=figName%>}}
      <%  } # for (ss ...) %>
 } % \subfloat{}
 \\
<%  } # for (kk ...) %>
    \end{center}
    \caption{
      Tumor versus normal BAFs of <%=getMethodLegends(names(signalList), lty=FALSE, col=FALSE)%> for region <%=region$src%>.
      Legend: SNPs genotyped (based on data from the corresponding method) as being heterozygous (homozygous) are displayed in black (gray).
    }
    \label{fig<%=figName%>}
    \end{figure}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
    % END Figure
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 



\clearpage
\section{ASCN plots}
<%
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
# Plot ASCNs
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
verbose && enter(verbose, "Plotting (C_A,C_B)")
what <- "ratios";

xlab <- expression(C["TA"] == theta["TA"]/theta[N]);
ylab <- expression(C["TB"] == theta["TB"]/theta[N]);
xlab <- expression(C["TA"]);
ylab <- expression(C["TB"]);
lim <- c(-0.5,4.5);

xScale <- 1e-6;
cp <- region$params$cp;
s <- region$params$s;
%>

<%
tbl <- sapply(signalList, FUN=getNbLociPerState);
if (byCount) {
  stopifnot(all(rowSds(tbl) == 0));
}
tbl <- tbl[,1, drop=TRUE];
%>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% BEGIN Figure: (C_A, C_B) for each state separately: <%=names(signalList)[kk]%>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\begin{figure}[htb]
  \begin{center}
<% methods <- names(signalList); %>
<%  for (kk in seq(along=signalList)) { %>
  \subfloat[<%=methods[kk]%>.]{
<%
    name <- names(signalList)[kk];
    signalsKK <- signalList[[kk]];

    for (ss in seq(along=ustates)) {
      signals <- subset(signalsKK, state == ustates[ss]);

      C <- signals$C;
      beta <- signals$betaT;
      # Sanity check
      stopifnot(length(beta) == length(C));

      CA <- (1-beta) * C;
      CB <- beta * C;
 
      # Homozygous & heterozygous color scheme
      isHet <- signals$isHet;
      col <- rep(homCol, times=nbrOfLoci(signals));
      col[isHet] <- hetCol;

      figName <- toFig(region$label, tags=c("ASCN", what, name, sprintf("state=%s", ustates[ss])), {
        par(mar=c(2.7,2.6,1.2,0)+0.1, mgp=c(1.4,0.3,0), tcl=-0.3, cex=cex, cex.axis=1.2, cex.lab=1.2);
        plot(NA, col=col, xlim=lim, ylim=lim, xlab=xlab, ylab=ylab);
        for (c in 2) lines(x=c(0,c), y=c(c,0), lty=1, lwd=2, col="#999999");
        ## boxes
        rLim <- c(floor(lim[1]), ceiling(lim[2]));
        z <- seq(from=rLim[1], to=rLim[2]);
        a <- rep(min(z), length(z));
        b <- rep(max(z), length(z));
        segments(a, z, b, z, col="#999999", lty=2);
        segments(z, a, z, b, col="#999999", lty=2);
        stext(side=3, pos=1, line=-0.3, cex=cex, names(tbl)[ss]);
        points(CA, CB, col=col, pch=pch, cex=cex);
     }) # toFig()
   %>%
   \resizebox{0.34\textwidth}{!}{\includegraphics{<%=figName%>}}
 <% } # for (ss ...) %>
 } % \subfloat{}
 \\
<%  } # for (kk ...) %>
  \end{center}
  \caption{
   Tumor ASCNs (allele-specific copy numbers) of <%=getMethodLegends(names(signalList), lty=FALSE, col=FALSE)%> for region <%=region$src%>.
   Legend: SNPs called heterozygous (homozygous) by the corresponing method are displayed in black (gray).
  }
  \label{fig<%=fullname(region$label, tags=c("ASCN", what, name))%>}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% END Figure
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

<% verbose && exit(verbose); %>



\clearpage
\section{ROC curves}
<%
signal <- signalList[[1]];
nbrOfLoci <- nbrOfLoci(signal, na.rm=TRUE);
fullRes <- (diff(xRange(signal))+1) / (nbrOfLoci-1);
%>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN Figure: ROC curves
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<%
xRange <- range(sapply(signalList, FUN=xRange));
%>

\begin{figure}[htb]
 \begin{center}
  \parbox{0.96\textwidth}{
<%
    for (ww in seq(along=binWidths)) {
      binWidth <- binWidths[ww];
      if (binWidth > 0) {
        if (byCount) {
          binLabel <- sprintf("Bin size: %g", round(binWidth));
        } else {
          binLabel <- sprintf("Bin width %g kb", binWidth/1e3);
        }
      } else {
        binLabel <- sprintf("Full resolution (%.1f kb, %s points)", fullRes/1e3, length(signal$unit));
      }

      figName <- toFig(region$label, tags=c("ROC", robustStr, sprintf("binWidth=%s", binWidth)), aspectRatio=1, scale=0.8, {
        par(mar=c(2.5,2.4,1.3,1)+0.1, mgp=c(1.4,0.3,0), tcl=-0.3, cex=cex);
        if (binWidth > 0) {
          # Smooth signal using consecutive bins of given width (in kb)
          signalSList <- lapply(signalList, FUN=function(signal) {
            binnedSmoothingByField(signal, field="state", fields=c("C", "rho"), from=xRange[1], to=xRange[2], by=binWidth, FUN=binFUN, byCount=byCount);
          });
        } else {
          signalSList <- signalList;
        }

        # Keep only states of interest (dropping safety zone)
        signalSList <- lapply(signalSList, FUN=function(signal) {
          subset(signal, is.element(state, ustates));
        });
        print(signalSList);

        cat("States:", ustates, "\n");
        methods <- names(signalSList);

        # ROC curve fits
        fitList <- NULL;
        colsT <- ltysT <- labelsT <- NULL;
        for (what in c("TCN", "DH")) {
          if (what == "TCN") {
            field <- "C";
          } else if (what == "DH") {
            field <- "rho";
          }

          labelsT <- c(labelsT, sprintf("%s,%s", what, methods));
          colsW <- getMethodColor(methods, what=what);
          ltysW <- getMethodLineType(methods, what=what);
          
          colsT <- c(colsT, colsW);
          ltysT <- c(ltysT, ltysW);

          cat("Evaluation statistics:", what, "\n");
          qs <- getQuantStates(ustates, what);
          cat("qs=", qs, "\n");
          recall <- ustates[which.min(qs)];
          ## In 'fitRoc', 'recall' is in fact the neutral state
          cat("Recall:", recall, "\n");
   
          for (ss in seq(along=signalSList)) {
            signalS <- signalSList[[ss]];
            cat("Number of missing values: ", sum(is.na(signalS[[field]])), "\n", sep="");
            roc <- fitRoc(signalS, field=field, states=ustates, recall=recall);
            fit <- list(roc=roc);
            fitList <- append(fitList, fit);
          } # for (ss ...)
        } # for (what ...)


        for (kk in seq(along=fitList)) {
          fit <- fitList[[kk]];
          roc <- fit$roc;
          lty <- ltysT[kk];
          col <- colsT[kk];

          if (kk == 1) {
            plot(roc, type="l", lwd=3, col=col, lty=lty, xlim=fpLim, ylim=sort(1-fpLim), xlab="False-positive rate", ylab="True-positive rate");
            abline(a=0, b=1, lty=3);
            stext(side=3, pos=1, binLabel, line=0, cex=0.8*cex);

            pcns <- sapply(ustates, FUN=getRegionPcns);
            pcnTxt <- apply(pcns, MARGIN=2, FUN=function(x) sprintf("(%s,%s)", x[1], x[2]));
            pcnTxt <- paste(pcnTxt, collapse=" vs ");
            stext(side=3, pos=0, line=0, cex=0.8*cex, pcnTxt);
       #     stext(side=4, pos=0, what, col="#999999", line=-0.4);

            doLgd <- ((ww == length(binWidths)) && (ww > 1));
            if (addLegend && doLgd) {
              legend("bottomright", col=colsT, lty=ltysT, lwd=2, labelsT, cex=0.4, bty="n");
            }
          } else {
            lines(roc, lwd=4, col=col, lty=lty);
          }
        } # for (kk ...)
      }) # toFig()
    %>%
    \subfloat[<%=binLabel%>.]{
     \resizebox{0.44\textwidth}{!}{\includegraphics{<%=figName%>}}
    } % \subfloat{}
   <% if (ww %% 2 == 0) { %>\\<% } %>%
 <% } # for (ww ...) %>%
  } % \parbox{}
 \end{center}
 \caption{ROC curves for detecting the change point based on TCNs and DHs for each preprocessing method at different amounts of smoothing ("resolutions") for region <%=region$src%>.
  Smoothing was done by averaging (using the <%=binFUN%>() function) in non-overlapping bins.
  Legend: The TCN and DH curves for the same method are depicted with the same line type and color with the difference that the TCN curve use a lighter version of color for <%=getMethodLegends(names(signalList), what="DH", nuanse=FALSE, collapse=TRUE)%>.
<%--  <%=legends%>. --%>
 }
 \label{fig<%=fullname(region$label, tags=c("ROC", robustStr))%>}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END Figure: ROC curves
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<%
exit(verbose);
%>



<% } # for (region ...) %>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END Regions of interest
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



<%--------------------------------------------------------------------
  TODO BEGIN
  --------------------------------------------------------------------

\clearpage
\chapter{Bootstrap estimates of test statistics for all regions}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN Regions of interest
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<%
testNames <- c("Student"="t", "Kolmogorov-Smirnov"="ks")[1];
%>

<% for (testLabel in names(testNames)) { %>

<% 
testName <- testNames[testLabel];

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Get the test function
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
fcnName <- sprintf("%s.test", testName);
testFUN <- get(fcnName, mode="function");
rm(fcnName);

# Setup test parameters
testParam <- "mean";
if (testName == "ks") {
  testParam <- "distribution";
}


allTstMeans <- NULL;
allTstSds <- NULL;
pcns <- NULL;

fixedNbPointsAcrossRegions <- (testName == "t");
%>

<% for (region in regionsList) { %>
<%
print(region);
%>

<%
## PCN states
pcns <- c(pcns, attr(region$params$s, "src"));
%>

<% 
  for (probeType in probeTypes) { 
    # Extract allele-specific signals

    # Sanity check
    signal <- signalList[[1]];
    cn$unit <- signal$unit;
    signalList[["TCN"]] <- cn; ## Add TCN
    rm(signal);

    # Remove NAs
    signalList <- lapply(signalList, FUN=function(signals) {
      isNA <- is.na(getSignals(signals));
      extractSubset(signals, whichVector(!isNA));
    });

    if (probeType == "heterozygous SNPs") {
      signalList <- sapply(genTags, FUN=function(genTag) {
        print(genTags);
        gcSet <- gcDsList[[genTag]];
        extractHeterozygous(signalList, gcSet);
      });

      dn <- dimnames(signalList);
      nms <- sapply(dn[[2]], FUN=function(nm) sprintf("%s,%s", dn[[1]], nm));
      nms <- as.character(nms);

      patts <- c("raw", sprintf("%s,%s", dn[[2]], dn[[2]]), "TCN");
      keep <- unlist(sapply(patts, FUN=grep, nms), use.names=FALSE);
      rm(patts);
      signalList <- signalList[keep];
      names(signalList) <- nms[keep];
    } # if (probeType == "heterozygous SNPs")

    if (fixedNbPointsAcrossMethods) {
      if (!fixedNbPointsAcrossRegions) {
        minNbPoints <- min(sapply(signalList, FUN=function(signals) {
          states <- signals$state;
          min(table(states));
        }));
      } else {
        # Now we resample with replacement (for practical purposes)
        # 100% SNPs => 250 loci, 90% SNPs => 225 loci
        minNbPoints <- 250;
      }
      verbose && cat(verbose, "Number of points sampled (with replacement) per bootstrap sample: ", minNbPoints);
    }

    if (!is.null(fixedSeed)) {
      set.seed(fixedSeed);
    }

    width <- getOption("width")-2;
    pb <- ProgressBar(max=width, stepLength=width/B);
    reset(pb);
    tstB <- sapply(1:B, FUN=function(x) {
      if (fixedNbPointsAcrossMethods) {
        signalListB <- lapply(signalList, FUN=getBalancedRegions, minNbPoints, replace=TRUE);
      } else {
        signalListB <- signalList;
      }
      tst <- sapply(signalListB, FUN=test, testFUN=testFUN, output=output);
      increase(pb);
      tst;
    });
    cat("\n");
    cat("B=", B);

    if (output == "p.value") {
      tstB <- -log(tstB);
    }
    tstB <- abs(tstB);

    tstMeans <- rowMeans(tstB);
    tstSds <- rowSds(tstB);
   
    names(tstMeans) <- names(signalList);
    allTstMeans[[what]][[probeType]] <- cbind(allTstMeans[[what]][[probeType]], tstMeans);
    allTstSds[[what]][[probeType]] <- cbind(allTstSds[[what]][[probeType]], tstSds);
  } ## for (probeType ...)
%>

<% } # for (region ...) %>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END Regions of interest
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<%
what <- "abs(fracB-1/2)";
  for (probeType in probeTypes) {
    tstMeans <- allTstMeans[[what]][[probeType]];
    tstSds <- allTstSds[[what]][[probeType]];
    # Sanity check
    stopifnot(all.equal(dim(tstMeans), dim(tstSds)));
  
    # Bootstrap results?
    if (B > 1) {
      tab <- sprintf("%.3f%s%.3f", tstMeans, pmTag, tstSds);
      txtB <- sprintf("Mean %s standard deviation across %s samplings of %s points (for each PCN state) from the original data set", pmTag, B, minNbPoints);
    } else {
      tab <- sprintf("%.3f", tstMeans);    
      txtB <- "";
    }
  
    tab <- matrix(tab, nrow=nrow(tstMeans), ncol=ncol(tstMeans));
    rownames(tab) <- names(signalList);
    colnames(tab) <- pcns;
    what2 <- ifelse(what == "fracB", "beta", "DH");
    output2 <- ifelse(output == "statistic", "test statistics", "p-value");

    caption <- sprintf("%s %s of the null hypothesis of equal %s before and after each PCN change point (%s): raw or postprocessed %s, and total copy number (last line). %s. The larger value, the more different the true %ss are.", testLabel, output2, testParam, probeType, what2, txtB, testParam);

    label <- sprintf("tab%s%s%s", testName, what2, toCamelCase(probeType));

    xt <- xtable(tab, caption=caption, label=label, table.placement="htb!");
    buf <- capture.output(print(xt, table.placement="htb!"));
    buf <- sprintf("%s\n", buf);
    tabStr <- gsub(pmTag, "$\\pm$", buf, fixed=TRUE);
    %><%=print(tabStr)%><%
   } ## for (probeType ...)
%>

<% } # for (testLabel ...) %>

  -------------------------------------------------------------------
  TODO BEGIN
  --------------------------------------------------------------------%>


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%   APPENDIX
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%=====================================================================
% References
%=====================================================================
\clearpage
\bibliography{bioinformatics-journals-abbr,hb-at-maths.lth.se}
%\bibliographystyle{plain}
\bibliographystyle{natbib}



%=====================================================================
% Data files
%=====================================================================
\clearpage
\appendix

\chapter{Data}
\section{Paired tumor-normal data}
\begin{lstlisting}
<%
x <- capture.output(print(dataList));
#x <- gsub(": .*/(rawCnData/)", ": \\1", x);
x <- paste(x, collapse="\n");
%>
<%=x%>
\end{lstlisting}


%=====================================================================
% Session information
%=====================================================================
\clearpage
\chapter{Session information}
This report was automatically generated using the R.rsp package.
<%=toLatex(sessionInfo())%>


\end{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% HISTORY:
% 2012-03-17 [HB]
% o Ready for submission to Bioinformatics.  Skipping the
%   bootstrapping; no time.
% 2012-03-15 [HB]
% o Got everything but the bootstrapping working.
% 2012-03-14 [HB]
% o We no longer need SegmentedCopyNumbers/SegmentedAlleleBFractions.
%   Instead we can make full use of the new RawGenomicSignals that
%   extends RichDataFrame (aroma.core >= 2.4.13).
% 2012-03-01 [HB]
% o Now longer assuming that RawGenericSignals are ref. variables.
% 2012-02-26 [HB]
% o Vignette now utilizing toPNG() and toPDF() of R.utils.
% o By using LaTeX 'grffile' package it is now possible to include
%   figure files with periods in their names, i.e. no longer needed
%   to escape those.
% o Finally got rid off paths in \includegraphics{}.  It turns out
%   that figure paths must have trailing slashes in \graphicspath{}.
% 2012-02-24 [PN]
% o Added support for multiple TCN data sets.
% 2012-02-19 [HB]
% o First steps toward generalizing this vignette to support multiple
#   postprocessing methods, e.g. TumorBoost and CalMaTe.
% 2011-03-18 [HB]
% o As a result of trying to rerun this vignette, I've added more
%   documentation to the header of this file and a few more
%   sanity checks.
% 2010-03-04 [PN]
% o Level of Heterozygosity -> Decrease in Heterozygosity
% 2009-12-08 [HB]
% o Clean out all non-LH evaluation code.
% o Clean out all non-LH evaluation code.
% o Lots of code clean up before submission.
% 2009-12-03 [HB]
% o Now using a fixed seed by default.
% o Made the axis labels greater for some plots.
% 2009-12-02 [HB]
% o CLEAN UP: Restructured functions and settings.
% o Fixed the random seed.
% o CLEAN UP: Removed the one-sample test-statistic tables.
% 2009-11-24 [HB]
% o Merged with tables.tex.rsp too.
% o Merged main.tex.rsp and plotByStates.tex.rsp.
% 2009-10-06 [PN]
% o ?
% 2009-08-23
% o Added evaluation based on major and minor CNs.
% 2009-09-06
% o WORKAROUND: For some unknown reasons does \graphicspath{} not 
%   work anymore; added explicity paths to figures.
% o Moved document configs to R/002.config.R.
% 2009-08-23
% o Updated the line styles ('ltys').
% 2009-07-02
% o Added support for PNG output.
% 2009-07-01
% o Added (betaN, betaT) plots stratified by state showing lines that
% motivate the correction factor in TBN,v2.
% 2009-06-30
% o Fixed byCount=FALSE.
% o Constrained the number of points to be the same for comparisons at a given resolution.
% 2009-06-29
% o Removed TBN (v1) tracks and ROC curves.
% o Added several flavors of ROC curves for total copy numbers.
% 2009-06-23
% o Fixed number of loci and state legends in figure captions.
% o Added tables with results of 'ks.test' and 't.test' to the evaluation.
% 2009-06-22
% o Added ks.test()$stat to fracB tracks.
% o Now only one panel in each figure.
% o Nicer plots.
% 2009-06-15
% o Added (betaN, betaT) plots.
% 2009-06-13
% o Added a track for ASCN.
% 2009-06-11
% o Added a track for TCN.
% 2009-06-10
% o Added a track for fracB.
% 2009-06-08
% o Replaced 'cn' by 'fracB'. Updated text accordingly.
% 2009-04-09
% o Language updates after feedback from TS.
% 2009-02-23
% o Created.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
