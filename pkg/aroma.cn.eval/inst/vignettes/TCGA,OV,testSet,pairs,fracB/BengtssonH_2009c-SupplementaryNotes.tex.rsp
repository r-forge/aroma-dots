%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Authors: Henrik Bengtsson, hb@stat.berkeley.edu
%          Pierre Neuvial, pierre@stat.berkeley.edu
% Created on: 2009-02-23
% Modified on: 2009-11-24
%
% Usage:
<%-- (RSP comment)
  library("R.rsp");
  fullnameRsp <- "BengtssonH_2009c-SupplementaryNotes";
  filenameRsp <- sprintf("%s.tex.rsp", fullnameRsp);
  filenameTeX <- sprintf("%s.tex", fullnameRsp);
  filenamePDF <- sprintf("%s.pdf", fullnameRsp);
  # => *.tex.rsp => ... => *.pdf
  rsptex(filenameRsp, envir=globalenv(), pdf=TRUE, force=TRUE, verbose=-5);
  pathnameTeX <- gsub(".pdf", ".tex", pdfPathname, fixed=TRUE);
  file.copy(filenameTeX, pathnameTeX, overwrite=TRUE);
  file.copy(filenamePDF, pdfPathname, overwrite=TRUE);

  # => *.tex.rsp => ... => *.pdf
#  # rsptex(filename, envir=globalenv(), pdf=TRUE, force=TRUE, verbose=-5);
--%>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

%=====================================================================
% Analysis setup
%=====================================================================
<%
verbose && enter(verbose, "Setup");
sourceDirectory("R/");

#regionsList <- regionsList[1];

fpLim <- c(0,0.6);
addLegend <- FALSE;
addSdEst <- FALSE;
trackWidth <- 0.9;
addDiagHorizLines <- TRUE;
plotSmoothScatter <- FALSE;

palette <- brewer.pal(n=9, name="Set1");


doB <- TRUE;
B <- 100;
B <- 5;
pmTag <- "@plusOrMinus@";

fixedNbPointsAcrossMethods <- c(TRUE, FALSE)[1];

output <- c("statistic", "p.value")[1];

# used when fixedNbPointsAcrossRegions is TRUE
minNbPoints <- 250;

# BUG: figForce must be TRUE
figForce <- FALSE;
#figForce <- 5;

title <- sprintf("Supplementary Note: Assessment of TumorBoost based on tumor/normal pair %s in the %s %s data set %s", sampleName, platform, chipTypeEsc, dataSet);
if (confQuantile < 1) {
  title <- sprintf("%s using the SNPs with %.0f\\%% highest confidence scores", title, 100*confQuantile);
}
authors <- "Henrik Bengtsson, Pierre Neuvial, Terence P. Speed";
verbose && exit(verbose);
%>

<%
pch <- 19; cex <- 0.5;
pch <- "."; cex <- 2.5;
colorMap <- c("*"="#000000", "NA"="#999999", "1"=palette[1], "2"=palette[5], "3"=palette[2], "4"=palette[4]);

fullResColorMap <- c("*" = "#000000", "NA" = "#999999");
smoothedColorMap <- c("*" = "#6666FF", "NA" = "#999999");
#smoothedColorMap <-  c("*" = "#000000", "NA" = "#999999");
hetCol <- "#000000";
homCol <- palette[1];
homCol <- "#999999";

evalSignals <- c("fracB", "abs(fracB-1/2)")[2];
probeTypes <- c("all SNPs", "Het SNPs")[2];

keepAllCombinations <- c(TRUE, FALSE)[2];
%>


%=====================================================================
% LaTeX setup
%=====================================================================
%\documentclass[a4paper,draft,10pt]{article}
\documentclass[a4paper,10pt]{article}
\usepackage{graphicx}
\usepackage{fancyvrb}
\usepackage{a4wide}
\usepackage{xspace}
\usepackage{amsmath} 
\usepackage{natbib}
\usepackage{subfig}

\addtolength{\oddsidemargin}{-10mm}
\addtolength{\textwidth}{10mm}
\addtolength{\topmargin}{-20mm}
\addtolength{\textheight}{20mm}

\renewcommand{\topfraction}{1.00}   % max fraction of floats at top
\renewcommand{\bottomfraction}{1.0} % max fraction of floats at bottom
\renewcommand{\textfraction}{0.00}

% The search path (within curly brackets and separated by commas)
% where to find graphics files
\graphicspath{{<%=figPath%>}}
\DeclareGraphicsRule{.eps.gz}{eps}{.eps.bb}{`gunzip -c #1}

\newcommand{\pkg}[1]{\textsl{#1}\xspace}
\newcommand{\trackWidth}{<%=trackWidth%>\textwidth}

\title{<%=title%>}
\author{<%=authors%>}

\begin{document}
\maketitle

\tableofcontents

\clearpage

%=====================================================================
% Introduction
%=====================================================================
\section{Introduction}
This report, which is automatically generated, assess the performance of the TumorBoost method based on a few chane points in a particular tumor/normal pair.


%=====================================================================
% Description of data set studied
%=====================================================================
% \clearpage
\section{Data set}

The evaluation is this report is based on the tumor/normal pair (<%=tumorType%>,<%=normalType%>) for individual <%=sampleName%> in the data set <%=dataSet%>. 

\subsection{Preprocessing methods}
The data was generated on the <%=platform%> <%=chipTypeEsc%> chip type.  

<% if (platform == "Affymetrix") { %>
  For Affymetrix, there is one CEL file per hybridization.
  <% if (is.element("CRMAv2", docTags)) { %>%
  Each CEL file was preprocessed separately using CRMAv2~\cite{BengtssonH_etal_2009b}, without relying neither on reference samples nor prior estimates.
  <% } %>%
  <% if (is.element("ismpolish", docTags)) { %>%
  The CEL files were preprocessed using Birdseed/median polish~\cite{KornJ_etal_2008} as part of a larger batch of CEL files.
  <% } %>%
<% } else if (platform == "Illumina") { %>%
  <% if (is.element("XY", docTags)) { %>%
  Each Illumina array was preprocessed separately using Birdseed's "XY-normalization" method, which is principle is a single-array method that relies neither on reference samples nor prior estimates.
  <% } %>%
  <% if (is.element("BAF", docTags)) { %>%
  Each Illumina array was preprocessed using Birdseed's "BAF" normalization method~\cite{PeifferD_etal_2006}, which is a multi-array (population-based) method.
  <% } %>%
<% } %>


<%
getRegionLabels <- function(state) {
  lab <- character(length=length(state));
  lab[state == 0] <- "'normal' (1,1)";
  lab[state == 1] <- "'gain' (1,2)";
  lab[state == 2] <- "'deletion' (0,1)";
  lab[state == 3] <- "'copy neutral LOH' (0,2)";
  lab;
} # getRegionLabels()

getRegionPcns <- function(state) {
  switch(state+1, c(1,1), c(1,2), c(0,1), c(0,2))
} # getRegionPcns()

getQuantStates <- function(states, evalSignal=c("TCN", "abs(fracB-1/2)", "minorCn", "majorCn")) {
  match.arg(evalSignal);

  pcns <- sapply(states, FUN=getRegionPcns);
  qs <- switch(evalSignal, 
    TCN = apply(pcns, MARGIN=2, FUN=sum),
    "abs(fracB-1/2)" = states,
    minorCn = pcns[1,],
    majorCn = pcns[2,]
  );

  ## if ties then order by TCN
  switch(length(unique(qs)), apply(pcns, MARGIN=2, FUN=sum), qs);
} # getQuantStates()
%>


\subsection{Stratification on genotype confidence scores}
<% if (confQuantile < 1) { %>
We focus on the SNPs in which we are the most confident that they are heterozygous: the evaluation will involve the <%=100*confQuantile%>\% SNPs with highest genotype confidence scores.
<% } else { %>
  No stratification on genotype confidence scores is done.  All SNPs are used in this evaluation.
<% } %>


%=====================================================================
% Description of change points studied
%=====================================================================
\subsection{List of change points}
For this data set, we have selected a few regions for which one safely can assume there exists a single changepoint and for which the fracB distribution looks constant.  This selection was done visually.  For each region we chose large enough safety margin such that the risk for the two sets $\mathcal{J}_A$ and $\mathcal{J}_B$ to contain loci from the other set is extremely small.  

\begin{table}[htb]
\begin{center}
\begin{tabular}{c|c|c|c|c|c}
Chr & Region & Change point & Margin & Before & After \\
\hline
<% for (region in regionsList) { %>
<%
sample <- region$name;
chr <- region$chromosome;
reg <- region$region/1e6;
## regionStr <- sprintf("%.2f", reg);
cp <- region$params$cp[1];
## cpStr <- sprintf("%.2f", cp);
delta <- region$params$cp[2];
## deltaStr <- sprintf("%.2f", delta);
regionLabels <- getRegionLabels(region$params$s);
%>
<%=chr%> & <%=reg[1]%>-<%=reg[2]%> & <%=cp%> & <%=delta%> & <%=regionLabels[1]%> & <%=regionLabels[2]%> \\ \hline
<% } # for (region ...) %>
\end{tabular}
\end{center}
\caption{Regions in <%=sample%> used for the evaluation and that each contain a single changepoint.  All positions and lengths are in units of Mb.}
\label{tblRegions}
\end{table}


We now compare the  raw, TBN-NGC, and TBN-Birdseed methods using the afformentioned ROC analysis at the full resolution as well as smoothed resolution with bin sizes $h=\{<%=paste(binCounts, collapse=", ")%>\}$.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% BEGIN Regions of interest
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<% for (region in regionsList) { %>
\clearpage
\section{Region: <%=region$src%>}

<%
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Count the number of loci with each state
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
getNbLociPerState <- function(object) {
  states <- getStates(object);
  tbl <- table(states, exclude=NULL);
  uniqueStates <- as.integer(names(tbl));
  o <- order(abs(uniqueStates));
  tbl <- tbl[o];
  names <- names(tbl);
  sign <- as.integer(names);
  names(tbl) <- getRegionLabels(sign);
  tbl
} # getNbLociPerState()
%>





<%
test <- function(signal, ...) {
  testSeparation(signal, test="ks.test")$statistic;
} # test()

test <- function(signal, testFUN, output=c("statistic")) {
  states <- getStates(signal);
  us <- na.omit(getUniqueStates(signal));
  # Sanity check
  stopifnot(length(us) == 2);
  signals <- getSignals(signal);
  res <- testFUN(signals[states == us[1]], signals[states == us[2]]);
  res[[output]];
} # test()

pcns <- NULL;
%>


<%
cnList <- NULL;
# Extract total CNs 
cnList <- getCnList(cnDsList, cnList=cnList, what="ratios");
cn <- cnList[[1]];
%>

<%
what <- ifelse(evalSignal == "abs(fracB-1/2)", "mBAF", evalSignal);
whatStr <- what;
if (whatStr == "mBAF") whatStr <- "Level of Heterozygosity (LH)";
%>

%%%%%%%%%%%%
% <%=what%>
%%%%%%%%%%%%


<% ## setup

signalList <- getFracBList(fracBDsList, what="fracB", pattern=methodPattern);
signalN <- getFracBList(list(dsN), what="fracB")[[1]];

enter(verbose, what);

###############
## BEGIN purifier
###############
enter(verbose, "purifier");
signalList <- lapply(signalList, FUN=function(signal) {
  signal$y <- (signal$y*cn$y-2*(1-kappaMain)*1/2) / (cn$y-2*(1-kappaMain));
  signal$y <- abs(signal$y-1/2);
  signal;
});

exit(verbose);
###############
## END purifier
###############

if (evalSignal == "minorCn" || evalSignal == "majorCn") {
  direction <- ifelse(evalSignal == "minorCn", -1, 1);
  enter(verbose, "Calculating minor/major CNs");
  signalList <- lapply(signalList, FUN=function(signal) {
    signal$y <- cn$y*(1/2 + direction*signal$y);
    signal;
  });

  exit(verbose);  
}

cn$y <- (cn$y-2*(1-kappaMain)) / kappaMain;

signal <- signalList[[1]];
signalList[["TCN"]] <- cn;
signalList[["TCN"]]$unit <- signalList[[1]]$unit;
 
signalList <- sapply(genTags, FUN=function(genTag) {
  extractHeterozygous(signalList, gcDsList[[genTag]], gcsDsList[[genTag]], confQuantile=confQuantile);
});
str(signalList);


## Number of het calls for each genotyping method, genome-wide.
## lapply(gcDsList, FUN=function(ds) {
##     df <- getFile(ds, 1); 
##     gens <- extractGenotypes(df); 
##     table(gens);
## });

dn <- dimnames(signalList);
nms <- sapply(dn[[2]], FUN=function(nm) sprintf("%s,%s", dn[[1]], nm));
nms <- as.character(nms);

nbrOfSets <- length(nms);
cols <- rep("#000000", times=nbrOfSets);
cols[regexpr("raw", nms) != -1] <- "#000000";
cols[regexpr("TCN", nms) != -1] <- palette[3];
cols[regexpr("TBN(,v[0-9]|),Birdseed", nms) != -1] <- palette[2];
cols[regexpr("TBN(,v[0-9]|),NGC", nms) != -1] <- palette[1];

ltys <- rep(1, times=nbrOfSets);
ltys[regexpr("raw", nms) != -1] <- 2;  # dot-dashed
ltys[regexpr("TCN", nms) != -1] <- 3;  # dotted
ltys[regexpr("TBN(,v[0-9]|),Birdseed", nms) != -1] <- 4; # dashed

labels <- strsplit(nms, split="\n");
labels <- sapply(labels, FUN=function(s) s[1]);
 
patts <- c("raw", sprintf("%s,%s", dn[[2]], dn[[2]]), "TCN");
keep <- unlist(sapply(patts, FUN=grep, nms));
##    keep <- seq(nms);
signalList <- signalList[keep];
names(signalList) <- nms[keep];

cols <- cols[keep];
ltys <- ltys[keep];
labels <- labels[keep];
nms <- nms[keep];
%>

<%  ## Add TCN
signalList[["TCN,SNP+CN"]] <- cn;
snps <- whichVector(!is.na(signal$y));
signalList[["TCN,SNP"]] <- extractSubset(cn, snps);

if (byCount) {
  minNbrOfPoints <- min(sapply(signalList, FUN=function(signal) {
    table(getStates(signal));
  }));
  if (!useFixedNbrOfPoints) {
   binCounts <-  binCounts * fixedNbrOfPoints/minNbrOfPoints;
    minNbrOfPoints <- fixedNbrOfPoints;
  }
  if (useFixedSeed) {
     set.seed(seed);
  }    
  signalList <- lapply(signalList, FUN=getBalancedRegions, minNbrOfPoints, replace=TRUE);
} # if (byCount)

cols <- c(cols,  rep(palette[3], 2));
ltys <- c(ltys,  2, 3);
nms <- names(signalList);
labels <- c(labels, "TCN,SNP+CN", "TCN,SNP");
%>

<% ## keep only some combinations for the evaluation
if (!plotAllRocCurves) {
  keep <- grep(rocCurvesPattern, names(signalList));
  signalList <- signalList[keep];
  cols <- cols[keep];
  ltys <- ltys[keep];
  nms <- nms[keep];
  labels <- labels[keep];
} # if (!plotAllRocCurves)
%>


<% if (plotTracks) { %>
%\clearpage
\subsection{<%=whatStr%> and total copy-number tracks}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN FIGURE: eval tracks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<%
rhoLim <- c(0, 1);
rhoLab <- expression(rho);
rhoLabT <- expression(tilde(rho));

cnLim <- c(0, 5);
cnLab <- expression(C == 2*(theta[T]/theta[N]));
cnLab <- "C";

xScale <- 1e-6;
xRange <- range(sapply(signalList, FUN=xRange));
states <- na.omit(getUniqueStates(signalList[[1]]));
xlim <- xRange*xScale;
cp <- region$params$cp;
s <- region$params$s;
xs <- cp["position"]+c(-1,+1)*cp["delta"];
figList <- list();
for (kk in seq(along=signalList)) {
  name <- names(signalList)[kk];
  signal <- signalList[[kk]];

  addStateLabels <- FALSE;
  ylim <- cnLim;
  if (length(grep("TCN", name))) {
    addStateLabels <- TRUE;
    ylab <- cnLab;
    figTag <- "ratios"
  } else if (evalSignal == "majorCn") {
    ylab <- expression(C[2]);
    figTag <- "majorCn";
  } else if (evalSignal == "minorCn") {
    ylab <- expression(C[3]);
    figTag <- "minorCn";
  } else {
    ylim <- rhoLim;
    if (length(grep("TBN", name))) {
      ylab <- rhoLabT;
    } else {
      ylab <- rhoLab;
    }
    figTag <- "MBAF";
  }

 setStateColorMap(signal, fullResColorMap);
  

  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
  # Plot along genome
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  figName <- sprintf("%s,%s,track,%s", region$label, figTag, name);
  if (fig <- figDev(figName, aspect=trackAspect)) {
    # subplots(nbrOfSources, ncol=1);
    par(mar=c(1.2,2,0.1,0)+0.2, mgp=c(1.2,0.3,0), tcl=-0.3, cex=cex, cex.axis=0.7);
    
    plot(signal, pch=pch, cex=cex, xlim=xlim, ylim=ylim, xScale=xScale, ylab=ylab);
    if (addStateLabels) {
      stext(side=3, pos=0, line=-0.2, cex=0.8*cex, names(tbl[1]))
      stext(side=3, pos=1, line=-0.2, cex=0.8*cex, names(tbl[2]))
    }

    ys <- par("usr")[3:4];
    dy <- 0.04*diff(ys);
    if (s[1] != 0) {
      rect(xlim[1],ys[1],xs[1],ys[1]+dy, col="#999999");
    } else {
      rect(xs[2],ys[1],xlim[2],ys[1]+dy, col="#999999");
    }
    rect(xs[1],ys[1],xs[2],ys[2], density=10, col="#999999");
##     stext(side=4, pos=1, line=-0.7, cex=cex, name, las=3);
  if (addSdEst) {
      sd <- estimateStandardDeviation(signal);
      stext(side=4, pos=1, line=-0.7, cex=0.8*cex, sprintf("SD=%.3g", sd));
    }
    if (addBinTrack) {
      binWidths <- binCounts;
      binWidth <- binWidths[length(binWidths)];
      if (!byCount) {
        binWidth <- round(diff(xRange(signal))/(nbrOfLoci(signal, na.rm=TRUE)-1)*binWidth)
      }
    signalS <- binnedSmoothingByState(signal, from=xRange[1], to=xRange[2], by=binWidth, FUN=binFFracB, byCount=byCount);
      setStateColorMap(signalS, smoothedColorMap);
      lines(signalS, lty=1, lwd=2, col="white", xScale=xScale);
      points(signalS, pch=19, cex=0.7, col="white", xScale=xScale);
      lines(signalS, lty=3, lwd=1, xScale=xScale);
      points(signalS, pch=19, cex=0.5, xScale=xScale);
    }
    ts <- signif(test(signal, testFUN=ks.test), digits=2)
 ##    stext(side=4, pos=0, line=-0.7, cex=0.8*cex, sprintf("KS = %s",ts), las=3)

   devDone(figName);
  } # if (figDev(...))
  figList[[kk]] <- fig;
} # for (kk ...)
%>

\begin{figure}[htb]
 \begin{center}
  <% for (fig in figList) { %>%
  \resizebox{\trackWidth}{!}{\includegraphics{<%=figPath%>/<%=fig$fullname%>}}
  <% } %>
 \end{center}
 \caption{<%=whatStr%> and total copy numbers for region <%=region$src%>. Only heterozygous SNPs are plotted. There are <%=tbl[1]%> loci of state <%=names(tbl)[1]%> ("negatives") and
  <%=tbl[2]%> loci of state <%=names(tbl)[2]%> ("positives"), where the
  latter are highlighted with a solid bar beneath. 
  In total <%=tbl[3]%> loci within the safety margin were excluded.
 }
 \label{fig<%=figName%>}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END FIGURE: rho tracks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<% } ## if (plotTracks) { %>

%\clearpage
\subsection{Allele B fraction density plots}
<%
verbose && enter(verbose, "Plotting densities");
what <- "fracB";
fracBList <- getFracBList(fracBDsList, what=what, pattern=methodPattern);
# Sanity check
stopifnot(length(fracBList) %in% c(2,3));   # raw, Birdseed*, NGC
fracB <- fracBList[[1]];
ustates <- na.omit(getUniqueStates(fracB));
%>

<%
tbl <- sapply(fracBList, FUN=getNbLociPerState);
stopifnot(all(rowSds(tbl) == 0));
tbl <- tbl[, 1];
%>

<%
xlab <- expression(beta[T]);
lim <- c(-0.1,1.1);
%>

<%
xlim <- c(-0.2,1.2);
platform <- getPlatform(fracBDsList[[1]]);
if (platform == "Affymetrix") {
  adjust <- 0.5; ylim <- c(0,3.2);
  adjust <- 0.3; ylim <- c(0,4.0);
} else if (platform == "Illumina") {
  adjust <- 0.3; ylim <- c(0,6.0);
}
%>

\begin{figure}[htb]
 \begin{center}
<%
#fracB <- fracBList[[1]];
#ustates <- na.omit(getUniqueStates(fracB));
for (ss in seq(along=ustates)) {
  figName <- sprintf("%s,%s,density,state=%s", region$label, what, ustates[ss]);
  fracBStateList <- lapply(fracBList, FUN=extractSubsetByState, ustates[ss]);
  betaT <- sapply(fracBStateList, FUN=getSignals);
%>%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% BEGIN Figure: betaT densities for state <%=ustates[ss]%>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
  \subfloat[<%=names(tbl)[ss]%>.]{
    <% 
    if (fig <- figDev(figName, aspect=0.4)) {
      par(mar=c(2.7,0.2,1.2,0.2)+0.1, mgp=c(1.4,0.3,0), tcl=-0.3, cex=cex);
      plotDensity(betaT, col="#000000", lty=c(3,1,1), lwd=6, adjust=adjust, xlim=xlim, ylim=ylim, xlab=xlab, ylab=NULL, axes=FALSE);
      axis(side=1, labels=FALSE, col.ticks=NA);
      axis(side=1, at=c(0,1/2,1));
      stext(side=3, pos=0.5, line=0, margin=c(0.2,0), cex=cex, names(tbl)[ss]);
      devDone(figName);
    } # if (figDev(...)) 
    %>%
   \resizebox{0.34\textwidth}{!}{\includegraphics{<%=figPath%>/<%=fig$fullname%>}}%
  } % \subfloat{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% END Figure
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
<%  } # for (ss ...) %>
 \end{center}
 \caption{Density of raw (dashed lines) and TumorBoost-normalized (solid lines) allele B fractions for region <%=region$src%>.}
 \label{fig<%=figName%>}
\end{figure}

<% verbose && exit(verbose); %>


\clearpage
\subsection{ROC curves}
<%
signal <- signalList[[1]];
nbrOfLoci <- sum(is.finite(signal$y), na.rm=TRUE);
fullRes <- (diff(xRange(signal))+1) / (nbrOfLoci-1);

binWidths <- binCounts;
if (byCount) {
} else {
  binWidths <- round(fullRes*binWidths);
}
%>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN Figure
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<%
  rocRows <- ceiling(length(binCounts)/rocCols); 
  aspect <- rocRows/rocCols;
  
  xRange <- range(sapply(signalList, FUN=xRange));
  states <- na.omit(getUniqueStates(signal));
%>

\begin{figure}[htb]
 \begin{center}
<%
     for (ww in seq(along=binWidths)) {
       binWidth <- binWidths[ww];
      
       smtFUN <- function(signal) {
           signalS <- binnedSmoothingByState(signal, from=xRange[1], to=xRange[2], 
           by=binWidth, FUN=binFFracB, byCount=byCount);
         signalS <- extractSubsetByState(signalS, states=states);
         signalS;
       }

       if (kappaMain != 1) {
         figName <- sprintf("%s,ROC,%s,binWidth=%s,kappa=%s", region$label, robustStr, binWidth, kappaMain);
       } else {
         figName <- sprintf("%s,ROC,%s,binWidth=%s", region$label, robustStr, binWidth);
       }
       if (fig <- figDev(figName, aspect=1, scale=0.5)) {
         ##   layout(matrix(seq(along=binWidths), ncol=rocCols, byrow=TRUE));
         par(mar=c(2.5,2.4,1.3,1)+0.1, mgp=c(1.4,0.3,0), tcl=-0.3, cex=cex);
    
     if (binWidth > 0) {
       # Smooth signal using consecutive bins of given width (in kb)
       signalSList <- lapply(signalList, FUN=smtFUN);
       dim(signalSList) <- dim(signalList)
        names(signalSList) <- names(signalList)

       if (byCount) {
         binLabel <- sprintf("Bin size: %g", round(binWidth));
       } else {
         binLabel <- sprintf("Bin width %g kb", binWidth/1e3);
      }
   } else {
      signalSList <- signalList;
      binLabel <- sprintf("Full resolution (%.1f kb, %s points)", fullRes/1e3, length(signal$unit));
    }
    print(signalSList);
  
    fits <- NULL;
    for (ss in seq(along=signalSList)) {
      signalS <- signalSList[[ss]];
      cat("Number of missing values: ", sum(is.na(getSignals(signalS))), "\n", sep="");
      es <- ifelse(length(grep("TCN", names(signalList)[ss])), "TCN", evalSignal);
      cat("Evaluation statistics:", es, "\n");
      cat("States:", states, "\n");
      qs <- getQuantStates(states, es);
      cat("qs=", qs, "\n");
      recall <- states[which.min(qs)]; ## In 'fitRoc', 'recall' is in fact the neutral state
      cat("Recall:", recall ,"\n");
      roc <- fitRoc(signalS, states=states, recall=recall);
      fits <- append(fits, list(roc));
    }
    names(fits) <- names(signalSList);     
  
   for (kk in seq(fits)) {
     doLgd <- ((kk == 1) && (ww == length(binWidths)) && (ww > 1));
     fit <- fits[[kk]];
     roc <- fit$roc;
     if (kk == 1) {
       plot(roc, type="l", lwd=3, col=cols[kk], lty=ltys[kk], xlim=fpLim, ylim=sort(1-fpLim), xlab="False-positive rate", ylab="True-positive rate");
       abline(a=0, b=1, lty=3);
       stext(side=3, pos=1, binLabel, line=0, cex=0.8*cex);
     } else {
       lines(roc, lwd=4, col=cols[kk], lty=ltys[kk]);
     }
     pcns <- sapply(states, FUN=getRegionPcns);
     pcnTxt <- apply(pcns, MARGIN=2, FUN=function(x) sprintf("(%s,%s)", x[1], x[2]));
     pcnTxt <- paste(pcnTxt, collapse=" vs ");
     stext(side=3, pos=0, pcnTxt, line=0, col="#999999", cex=0.8*cex);
#     stext(side=4, pos=0, what, col="#999999", line=-0.4);
     if (kappaMain != 1) {
       stext(side=4, pos=1, sprintf("k=%s", kappaMain), col="#999999", line=-0.4, cex=0.8*cex);
     }

     if (addLegend && doLgd) {
       legend("bottomright", col=cols, lwd=2, lty=ltys, labels, cex=0.4, bty="n");
     }
   } # for (kk ...)
   devDone(figName);
 } # if (figDev(...)) %>%
  \resizebox{0.45\textwidth}{!}{\includegraphics{<%=figPath%>/<%=fig$fullname%>}}
<% } # for (ww ...) %>
\end{center}
 \caption{ROC curves for each preprocessing method at the full resolution as well as <%=length(binWidths)-1%> different amounts of smoothing (using the <%=binFFracB%>() function) for region <%=region$src%>.}
 \label{fig<%=figName%>}
\end{figure}

<% 
  ltyLgds <- rep("solid", length(ltys))
  ltyLgds[ltys == 2] <- "dashed"
  ltyLgds[ltys == 3] <- "dotted"
  ltyLgds[ltys == 4] <- "dash-dotted"
  
  lgd <- cbind(ltyLgds, cols)
  rownames(lgd) <- nms
  colnames(lgd) <- c("line type", "color")
  
  caption <- sprintf("Legend of Figure \\ref{fig%s}.", figName)
%>
<%=print(xtable(lgd, caption=caption), table.placement="htb!") %>


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END Figure
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<%
exit(verbose);
%>

\clearpage
\subsection{$(\beta_N, \beta_T)$ plots}
<%
verbose && enter(verbose, "Plotting (beta_N, beta_T)")
what <- "fracB"
fracBList <- getFracBList(fracBDsList, what=what, pattern=methodPattern);

fracBN <- getFracBList(list(dsN), what=what)[[1]];
betaN <- getSignals(fracBN);

print(fracBList);
nbrOfSources <- length(fracBList);
%>
<%
 xScale <- 1e-6;
 cp <- region$params$cp;
  s <- region$params$s;
 
  xlab <- expression(beta[N] == theta[B,N]/theta[N]);
  ylab <- expression(beta[T] == theta[B,T]/theta[T]);
  xlab <- expression(beta[N]);
  ylab <- expression(beta[T]);
  lim <- c(-0.1,1.1);

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
# Plot $(\beta_N, \beta_T)$
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
%>
<%
tbl <- sapply(fracBList, FUN=getNbLociPerState);
stopifnot(all(rowSds(tbl) == 0));
tbl <- tbl[, 1];
%>
<%  for (kk in seq(along=fracBList)) { %>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% BEGIN Figure: (betaN, betaT) for each state separately: <%=names(fracBList)[kk]%>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\begin{figure}[htb]
  \begin{center}
<%
    name <- names(fracBList)[kk];
    fracB <- fracBList[[kk]];
    ustates <- na.omit(getUniqueStates(fracB));
    for (ss in seq(along=ustates)) {
      fracBState <- extractSubsetByState(fracB, state=ustates[ss]);
      fracBNState <- extractSubsetByState(fracBN, state=ustates[ss]);
      betaN <- getSignals(fracBNState)

      betaT <- getSignals(fracBState);

      ## genotype calls
      genName <- unlist(strsplit(name, ","))
      genName <- genName[length(genName)]
      gTag <- ifelse(genName == "raw", genTag, genName);
      gcN <- gcDsList[[gTag]]
      idx <- indexOf(gcN, region$name);
      gf <- getFile(gcN, idx);
      isHet <- isHeterozygous(gf, units=fracBNState$unit, drop=TRUE);
      txt <- sprintf("%s,%s", name, gTag);
      
      col <- rep(homCol, length(isHet));
      col[isHet] <-hetCol;

      figName <- sprintf("%s,betaNvsBetaT,%s,%s,%s,state=%s", region$label, what, name, gTag, ustates[ss]);
      if (fig <- figDev(figName)) {
        par(mar=c(2.7,2.6,1.2,0)+0.1, mgp=c(1.4,0.3,0), tcl=-0.3, cex=cex);
        plot(NA, xlim=lim, ylim=lim, xlab=xlab, ylab=ylab, axes=FALSE);
        axis(side=1, at=c(0,1/2,1));
        axis(side=2, at=c(0,1/2,1));
##        box();  # optional?

        if (addDiagHorizLines) {	
          if(name == "raw") {
            ys <- seq(0.0, 1.0, by=0.1);
            for (y in ys) {
              lines(x=c(0,1-y), y=c(y,1), col="#999999", lty=1, lwd=1);
              lines(x=c(1,y), y=c(1-y,0), col="#999999", lty=1, lwd=1);
            }
          } else { 
            ys <- seq(0.0, 1.0, by=0.1);
            for (y in ys) {
              lines(x=c(0,1), y=c(y,y), col="#999999", lty=1, lwd=1);
            }
          }
	}

        ## boxes
        z <- 0:2/2;
        a <- rep(min(z), length(z));
        b <- rep(max(z), length(z));
        segments(a, z, b, z, col="#999999", lty=2);
        segments(z, a, z, b, col="#999999", lty=2);

        points(betaN, betaT, pch=pch, col=col, cex=cex);

        if ((addTrueBetaLines) && (name == "raw")) {
          ## slope: exploiting symmetries...
          slopeDatAbove <- betaT/betaN;
          slopeDatBelow <- (1-betaT)/(1-betaN);
          slopeDat <- slopeDatAbove;
          slopeDat[which(slopeDat>1)] <- slopeDatBelow[which(slopeDat>1)];
          
          hetSlope <- median(slopeDat[isHet], na.rm=TRUE);
          
          abline(a=0, b=1, lty=2, lwd=2, col="#999999");
          x0 <- rep(0, 2);
          x1 <- rep(1, 2);
          y0 <- c(0, 1-hetSlope);
          y1 <- c(hetSlope, 1);
          segments(x0, y0, x1, y1, lty=1, lwd=6, col="white");
          segments(x0, y0, x1, y1, lty=1, lwd=4, col=hetCol);
        }
        
##         if ((addLinearRegressionLines) && (name == "raw")) {
        if ((addLinearRegressionLines)) {
          
          if (name == "raw") {
            isBelow <- (betaT < betaN);
          } else {
            isBelow <- (betaT<1/2);
         };
          wBelow <- whichVector(isHet & isBelow);
          wAbove <- whichVector(isHet & !isBelow);
          xxBelow <- c(betaN[wBelow], 1-betaN[wAbove]);
          yyBelow <- c(betaT[wBelow], 1-betaT[wAbove]);
          xxAbove <- 1-xxBelow;
          yyAbove <- 1-yyBelow;
        
          lmBelow <- lm(betaT[wBelow]~betaN[wBelow]);
          lmAbove <- lm(betaT[wAbove]~betaN[wAbove]);

          ##           lmBelow <- rlm(betaT[wBelow]~betaN[wBelow], weights=abs(betaN[wBelow]-1/2));
          ##           lmBelow <- rlm(betaT[wBelow]~betaN[wBelow]);
          lmBelow <- rlm(yyBelow~xxBelow);
          ##           lmAbove <- rlm(betaT[wAbove]~betaN[wAbove], weights=abs(betaN[wAbove]-1/2));
          ##           lmAbove <- rlm(betaT[wAbove]~betaN[wAbove]);
          lmAbove <- rlm(yyAbove~xxAbove);

          xb <- 1/2;
          abline(lmBelow, lwd=9, col="white");
          abline(lmBelow, lwd=6, col=hetCol, lty=1);
          coef <- lmBelow$coefficients
          yb <- coef[1]+xb*coef[2];
          points(xb, yb, col="white", cex=2.6, pch=20);
          points(xb, yb, col=hetCol, cex=2, pch=20);
          abline(lmAbove, lwd=9, col="white");
          abline(lmAbove, lwd=6, col=hetCol, lty=1);
          coef <- lmAbove$coefficients
          yb <- coef[1]+xb*coef[2];
         points(xb, yb, col="white", cex=2.6, pch=20);
         points(xb, yb, col=hetCol, cex=2, pch=20);
         points(xb, yb, col=hetCol, cex=2, pch=1);
       }
        
       nm <- names(tbl)[ss];
       stext(side=3, pos=0, line=-0.3, cex=cex, nm);
#       stext(side=4, pos=0, line=-0.8, cex=cex, txt, col="#999999");

       if (addTrueBetaPoints) {         ## add points for true allele B fractions
         for (kk in seq(along=kappasPbs)) {
            kappa <- kappasPbs[kk];
            tbc <- (3:5)[kk];
            tbCex <- c(2, 1.5, 1)[kk];
            points(0,0, col=tbc, cex=tbCex, pch=20);
            points(1,1, col=tbc, cex=tbCex, pch=20);
            trueBeta <- switch(nm,
              "NORMAL (1,1)" = 1/2,
              "GAIN (1,2)" = (1*kappa+(1-kappa))/(3*kappa+2*(1-kappa)),
              "DELETION (0,1)" = (1-kappa)/(kappa+2*(1-kappa)),
              "COPY NEUTRAL LOH (0,2)" = (1-kappa)/2);
            points(1/2, trueBeta, col=tbc, cex=tbCex, pch=20)
            points(1/2, 1-trueBeta, col=tbc, cex=tbCex, pch=20)
          }
        }
        devDone(figName);
      } # if (figDev(...)) %>%
      \resizebox{0.34\textwidth}{!}{\includegraphics{<%=figPath%>/<%=fig$fullname%>}}
      <%  } # for (ss ...) %>
    \end{center}
    \caption{<%=txt%> for region <%=region$src%>.}
    \label{fig<%=figName%>}
    \end{figure}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
    % END Figure
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
<%         if (plotSmoothScatter && name == "raw") { %>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% BEGIN Figure: (betaN, betaT) for each state separately: <%=names(fracBList)[kk]%>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\begin{figure}[htb]
  \begin{center}
<%
    name <- names(fracBList)[kk];
    fracB <- fracBList[[kk]];
    ustates <- na.omit(getUniqueStates(fracB));
    for (ss in seq(along=ustates)) {
      fracBState <- extractSubsetByState(fracB, state=ustates[ss]);
      fracBNState <- extractSubsetByState(fracBN, state=ustates[ss]);
      betaN <- getSignals(fracBNState)

      betaT <- getSignals(fracBState);

      ## genotype calls
      genName <- unlist(strsplit(name, ","))
      genName <- genName[length(genName)]
      gTag <- ifelse(genName == "raw", genTag, genName);
      gcN <- gcDsList[[gTag]]
      idx <- indexOf(gcN, region$name);
      gf <- getFile(gcN, idx);
      isHet <- isHeterozygous(gf, units=fracBNState$unit, drop=TRUE);
      txt <- sprintf("%s,%s --- smoothScatter version", name, gTag);
      
      col <- rep(homCol, length(isHet));
      col[isHet] <-hetCol;

      isBelowDiagonal <- (betaT<betaN);
      xx <- median(betaN[isBelowDiagonal & isHet], na.rm=TRUE);
      yy <- median(betaT[isBelowDiagonal & isHet], na.rm=TRUE);

      figName <- sprintf("%s,betaNvsBetaT,%s,%s,%s,smoothScatter,state=%s", region$label, what, name, gTag, ustates[ss]);
      if (fig <- figDev(figName)) {
        par(mar=c(2.7,2.6,1.2,0)+0.1, mgp=c(1.4,0.3,0), tcl=-0.3, cex=cex);
        smoothScatter(betaN, betaT, xlim=lim, ylim=lim, xlab=xlab, ylab=ylab, axes=FALSE)
       axis(side=1, at=c(0,1/2,1));
        axis(side=2, at=c(0,1/2,1));
##        box();  # optional?

        abline(a=0, b=yy/xx);
        abline(v=xx);
        abline(v=0.5);
        abline(h=yy);
        abline(h=yy/xx*0.5);

        stext(side=3, pos=0, line=-0.3, cex=cex, names(tbl)[ss]);
#        stext(side=4, pos=0, line=-0.8, cex=cex, txt, col="#999999");
        devDone(figName);
      } # if (figDev(...)) %>%
      \resizebox{0.34\textwidth}{!}{\includegraphics{<%=figPath%>/<%=fig$fullname%>}}
      <%  } # for (ss ...) %>
    \end{center}
    \caption{<%=txt%> for region <%=region$src%>.}
    \label{fig<%=figName%>}
    \end{figure}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
    % END Figure
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
      <%  } # if (name ... %>
 <%  } # for (kk ...) %>



\clearpage
\subsection{Allele-specific copy number estimates}
<%
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
# Plot ASCNs
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
verbose && enter(verbose, "Plotting (C_A,C_B)")
what <- "ratios";

xlab <- expression(C["TA"] == theta["TA"]/theta[N]);
ylab <- expression(C["TB"] == theta["TB"]/theta[N]);
xlab <- expression(C["TA"]);
ylab <- expression(C["TB"]);
lim <- c(-0.5,4.5);

# Extract total CNs 
cnList <- getCnList(cnDsList, what=what);
cn <- cnList[[1]];
print(cn);
C <- getSignals(cn);
col <- getStateColors(cn, na.rm=TRUE);

fracBList <- getFracBList(fracBDsList, what="fracB", pattern=methodPattern);
print(fracBList);
nbrOfSources <- length(fracBList);

  xScale <- 1e-6;
  states <- na.omit(sort(getUniqueStates(fracBList[[1]])));
  cp <- region$params$cp;
  s <- region$params$s;
%>

<%
tbl <- sapply(fracBList, FUN=getNbLociPerState);
stopifnot(all(rowSds(tbl) == 0));
tbl <- tbl[, 1];
%>

<%  for (kk in seq(along=fracBList)) { %>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% BEGIN Figure: (C_A, C_B) for each state separately: <%=names(fracBList)[kk]%>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\begin{figure}[htb]
  \begin{center}
<%
    name <- names(fracBList)[kk];
    fracB <- fracBList[[kk]];
    ustates <- na.omit(getUniqueStates(fracB));
    for (ss in seq(along=ustates)) {
      state <- ustates[ss];
      cnState <- extractSubsetByState(cn, state=state);
      fracBState <- extractSubsetByState(fracB, state=state);
      fracBNState <- extractSubsetByState(fracBN, state=state);

      C <- getSignals(cnState);
      beta <- getSignals(fracBState);
      # Sanity check
      stopifnot(length(beta) == length(C));

      CA <- (1-beta) * C;
      CB <- beta * C;
 
      ## genotype calls
      genName <- unlist(strsplit(name, ","))
      genName <- genName[length(genName)]
      gTag <- ifelse(genName == "raw", genTag, genName);
      gcN <- gcDsList[[gTag]]
      idx <- indexOf(gcN, region$name);
      gf <- getFile(gcN, idx);
      isHet <- isHeterozygous(gf, units=fracBNState$unit, drop=TRUE);
      
      col <- rep(homCol, length(isHet));
      col[isHet] <-hetCol;

      figName <- sprintf("%s,ASCN,%s,%s,%s,state=%s", region$label, what, name, gTag, state);
      if (fig <- figDev(figName)) {
        par(mar=c(2.7,2.6,1.2,0)+0.1, mgp=c(1.4,0.3,0), tcl=-0.3, cex=cex);
        plot(NA, col=col, xlim=lim, ylim=lim, xlab=xlab, ylab=ylab);
        for (c in 2) lines(x=c(0,c), y=c(c,0), lty=1, lwd=2, col="#999999");
        ## boxes
        rLim <- c(floor(lim[1]), ceiling(lim[2]));
        z <- seq(from=rLim[1], to=rLim[2]);
        a <- rep(min(z), length(z));
        b <- rep(max(z), length(z));
        segments(a, z, b, z, col="#999999", lty=2);
        segments(z, a, z, b, col="#999999", lty=2);

        txt <- sprintf("%s,%s", name, gTag);
        stext(side=3, pos=1, line=-0.3, cex=cex, names(tbl)[ss]);
#        stext(side=4, pos=0, line=-0.8, cex=cex, txt, col="#999999");
        points(CA, CB, col=col, pch=pch, cex=cex);
        devDone(figName);
      } # if (figDev(...)) %>%
      \resizebox{0.34\textwidth}{!}{\includegraphics{<%=figPath%>/<%=fig$fullname%>}}
 <% } # for (ss ...) %>
    \end{center}
    \caption{<%=txt%> for region <%=region$src%>.}
    \label{fig<%=figName%>}
    \end{figure}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
    % END Figure
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
 <%  } # for (kk ...) %>

<% verbose && exit(verbose); %>


<% } # for (region ...) %>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END Regions of interest
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\clearpage
\section{Bootstrap estimates of test statistics for all regions}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN Regions of interest
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<% for (testLabel in names(testNames)) { %>

<% 
allTstMeans <- NULL;
allTstSds <- NULL;
pcns <- NULL;
%>

<% for (region in regionsList) { %>
<%
print(region);
%>
%%%%%%%%
%% TCN
%%%%%%%%
<%
cnList <- NULL;
# Extract total CNs 
cnList <- getCnList(cnDsList, cnList=cnList, what="ratios");
cn <- cnList[[1]];
%>

<%
## PCN states
pcns <- c(pcns, attr(region$params$s, "src"));
%>

<% 
for (what in evalSignals) { 
  for (probeType in probeTypes) { 

    signalList <- getFracBList(fracBDsList, what=what, pattern=methodPattern);

    ## remove NAs
    signalList <- lapply(signalList, FUN=function(fracB) {
      isNA <- is.na(getSignals(fracB));
      fracB <- extractSubset(fracB, whichVector(!isNA));
    });

    signalList[["TCN"]] <- cn; ## Add TCN
    signalList[["TCN"]]$unit <- signalList[[1]]$unit;

    if (probeType == "Het SNPs") {
      signalList <- sapply(genTags, FUN=function(genTag) {
        extractHeterozygous(signalList, gcDsList[[genTag]], gcsDsList[[genTag]], confQuantile=confQuantile);
      });

      dn <- dimnames(signalList);
      nms <- sapply(dn[[2]], FUN=function(nm) sprintf("%s,%s", dn[[1]], nm));
      nms <- as.character(nms);

      patts <- c("raw", sprintf("%s,%s", dn[[2]], dn[[2]]), "TCN");
      keep <- unlist(sapply(patts, FUN=grep, nms));
      signalList <- signalList[keep];
      names(signalList) <- nms[keep];

      ## Add TCN
      signalList[["TCN,SNP+CN"]] <- cn;
      snps <- whichVector(!is.na(signalList[[1]]$y))
      signalList[["TCN,SNP"]] <- extractSubset(cn, snps)

      ## keep only some combinations for the evaluation
      if (!keepAllCombinations) {
        keep <- grep(rocCurvesPattern, names(signalList))
        signalList <- signalList[keep];
      }
    } # if (probeType == "Het SNPs")
    str(signalList);

    if (!fixedNbPointsAcrossRegions && fixedNbPointsAcrossMethods) {
      minNbPoints <- min(sapply(signalList, FUN=function(fracB) {
        table(getStates(fracB));
      }));
    }

    testName <- testNames[testLabel];
    fcnName <- sprintf("%s.test", testName);
    testFUN <- get(fcnName, mode="function");

    width <- getOption("width")-2;
    pb <- ProgressBar(max=width, stepLength=width/B);
    reset(pb);
    tstB <- sapply(1:B, FUN=function(x) {
      if (fixedNbPointsAcrossMethods) {
        signalListB <- lapply(signalList, FUN=getBalancedRegions, minNbPoints);
      } else {
        signalListB <- signalList;
      }
      tst <- sapply(signalListB, FUN=test, testFUN=testFUN, output=output);
      increase(pb);
      tst;
    });
    cat("\n");

    if (output == "p.value") {
      tstB <- -log(tstB);
    }
    tstB <- abs(tstB);

    tstMeans <- rowMeans(tstB);
    tstSds <- rowSds(tstB);
   
    names(tstMeans) <- names(signalList);
    allTstMeans[[what]][[probeType]] <- cbind(allTstMeans[[what]][[probeType]], tstMeans);
    allTstSds[[what]][[probeType]] <- cbind(allTstSds[[what]][[probeType]], tstSds);
  } ## for (probeType ...)
} ## for (what ...)
%>

<% } # for (region ...) %>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END Regions of interest
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<%
for (what in evalSignals) {
  for (probeType in probeTypes) {
    tstMeans <- allTstMeans[[what]][[probeType]];
    tstSds <- allTstSds[[what]][[probeType]];
    # Sanity check
    stopifnot(all.equal(dim(tstMeans), dim(tstSds)));
  
    # Bootstrap results?
    if (doB) {
      tab <- sprintf("%.3f%s%.3f", tstMeans, pmTag, tstSds);
    } else {
      tab <- sprintf("%.3f", tstMeans);    
    }
  
    tab <- matrix(tab, nrow=nrow(tstMeans), ncol=ncol(tstMeans));
    rownames(tab) <- names(signalList);
    colnames(tab) <- pcns;
    what2 <- ifelse(what == "fracB", "beta", "rho");
    output2 <- ifelse(output == "statistic", "test statistics", "p-value");

    if (doB) {
      txtB <- sprintf("Mean %s standard deviation of %s subsamplings of the original data set. ", pmTag, B);
    } else {
      txtB <- "";
    }

    caption <- sprintf("%s %s of the null hypothesis of equal mean before and after each PCN change point (%s): raw or TumorBoost-normalized %s, and total copy number (last line). %sThe larger value, the more different the distributions are.", testLabel, output2, probeType, what2, txtB);

    label <- sprintf("tab%s%s%s", testName, what2, toCamelCase(probeType));

    xt <- xtable(tab, caption=caption, label=label, table.placement="htb!");
    buf <- capture.output(print(xt, table.placement="htb!"));
    buf <- sprintf("%s\n", buf);
    tabStr <- gsub(pmTag, "$\\pm$", buf, fixed=TRUE);
    %><%=print(tabStr)%><%
   } ## for (probeType ...)
} ## for (what ...)
%>

<% } # for (testLabel ...) %>



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%   APPENDIX
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%=====================================================================
% References
%=====================================================================
\clearpage
\bibliography{bioinformatics-journals-abbr,hb-at-maths.lth.se}
%\bibliographystyle{plain}
\bibliographystyle{natbib}


%=====================================================================
% Data files
%=====================================================================
\clearpage
\appendix
\section{Data files}
\begin{Verbatim}[fontfamily=helvetica,fontsize=\small]
<%={x <- capture.output(print(fracBDsList));x <- gsub(": .*/(totalAndFracBData/)", ": \\1", x);paste(x, collapse="\n");}%>
\end{Verbatim}


%=====================================================================
% Session information
%=====================================================================
\clearpage
\section{Session information}
This report was automatically generated using the R.rsp package.
<%=toLatex(sessionInfo())%>


\end{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% HISTORY:
% 2009-11-24 [HB]
% o Merged with tables.tex.rsp too.
% o Merged main.tex.rsp and plotByStates.tex.rsp.
% 2009-10-06 [PN]
% o ?
% 2009-08-23
% o Added evaluation based on major and minor CNs.
% 2009-09-06
% o WORKAROUND: For some unknown reasons does \graphicspath{} not 
%   work anymore; added explicity paths to figures.
% o Moved document configs to R/002.config.R.
% 2009-08-23
% o Updated the line styles ('ltys').
% 2009-07-02
% o Added support for PNG output.
% 2009-07-01
% o Added (betaN, betaT) plots stratified by state showing lines that
% motivate the correction factor in TBN,v2.
% 2009-06-30
% o Fixed byCount=FALSE.
% o Constrained the number of points to be the same for comparisons at a given resolution.
% 2009-06-29
% o Removed TBN (v1) tracks and ROC curves.
% o Added several flavors of ROC curves for total copy numbers.
% 2009-06-23
% o Fixed number of loci and state legends in figure captions.
% o Added tables with results of 'ks.test' and 't.test' to the evaluation.
% 2009-06-22
% o Added ks.test()$stat to fracB tracks.
% o Now only one panel in each figure.
% o Nicer plots.
% 2009-06-15
% o Added (betaN, betaT) plots.
% 2009-06-13
% o Added a track for ASCN.
% 2009-06-11
% o Added a track for TCN.
% 2009-06-10
% o Added a track for fracB.
% 2009-06-08
% o Replaced 'cn' by 'fracB'. Updated text accordingly.
% 2009-04-09
% o Language updates after feedback from TS.
% 2009-02-23
% o Created.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
