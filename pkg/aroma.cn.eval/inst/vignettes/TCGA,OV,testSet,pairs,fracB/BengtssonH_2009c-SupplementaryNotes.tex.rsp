%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Authors: Henrik Bengtsson, hb@stat.berkeley.edu
%          Pierre Neuvial, pierre@stat.berkeley.edu
% Created on: 2009-02-23
% Modified on: 2009-11-24
%
% Usage:
%  library("R.rsp");
%  rsptex("main .tex.rsp");  # => *.tex.rsp => ... => *.dvi
%  rsptex("main.tex.rsp", pdf=TRUE);  # => *.tex.rsp => ... => *.pdf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

%=====================================================================
% Analysis setup
%=====================================================================
<%
verbose && enter(verbose, "Setup");
sourceDirectory("R/");

fpLim <- c(0,0.6);
addLegend <- TRUE;
addSdEst <- FALSE;
trackWidth <- 0.9;

doB <- TRUE;
B <- 100;
pmTag <- "@plusOrMinus@";

fixedNbPointsAcrossMethods <- c(TRUE, FALSE)[1];

output <- c("statistic", "p.value")[1];

# used when fixedNbPointsAcrossRegions is TRUE
minNbPoints <- 250;

figForce <- 1;

title <- sprintf("Single sample assessment of the TumorBoost method based on the '%s' data set", dataSet);
authors <- "HB, PN.";
verbose && exit(verbose);
%>

<%
pch <- 19; cex <- 0.5;
pch <- "."; cex <- 2.5;
colorMap <- c("*"="#000000", "NA"="#999999", "1"="red", "2"="orange", "3"="blue", "4"="purple");

fullResColorMap <- c("*" = "#000000", "NA" = "#999999");
smoothedColorMap <- c("*" = "#6666FF", "NA" = "#999999");
#smoothedColorMap <-  c("*" = "#000000", "NA" = "#999999");
homCol <- 2;
hetCol <- 1;

evalSignals <- c("fracB", "abs(fracB-1/2)")[2];
probeTypes <- c("all SNPs", "Het SNPs")[2];

keepAllCombinations <- c(TRUE, FALSE)[2];

#regions <- regions[1:2];
%>


%=====================================================================
% LaTeX setup
%=====================================================================
%\documentclass[a4paper,draft,10pt]{article}
\documentclass[a4paper,10pt]{article}
\usepackage{graphicx}
\usepackage{fancyvrb}
\usepackage{a4wide}
\usepackage{xspace}
\usepackage{amsmath} 
\usepackage{natbib}
\usepackage{subfig}

\addtolength{\oddsidemargin}{-10mm}
\addtolength{\textwidth}{10mm}
\addtolength{\topmargin}{-20mm}
\addtolength{\textheight}{20mm}

\renewcommand{\topfraction}{1.00}    % max fraction of floats at top
\renewcommand{\bottomfraction}{1.0} % max fraction of floats at bottom
\renewcommand{\textfraction}{0.00}

% The search path (within curly brackets and separated by commas)
% where to find graphics files
\graphicspath{{<%=figPath%>}}
\DeclareGraphicsRule{.eps.gz}{eps}{.eps.bb}{`gunzip -c #1}

\newcommand{\pkg}[1]{\textsl{#1}\xspace}
\newcommand{\trackWidth}{<%=trackWidth%>\textwidth}

\title{<%=title%>}
\author{<%=authors%>}

\begin{document}
\maketitle

\tableofcontents

\clearpage

%=====================================================================
% Introduction
%=====================================================================
\section{Introduction}
This report, which is automatically generated, assess the performance of the TumorBoost method based on a few change points in a particular tumor/normal pair.


\section{Method}
Consider a local genomic region with loci where there exists exactly one change point in the distribution of the allele B fraction (fracB, or $\beta$) at position $x_0$ and that the true distribution at each side of the changepoint is constant.

Assume that we can (visually) identify this changepoint and with very high confidence locate it to be within $[x_0-\delta, x_0+\delta)$ where we refer to $\delta$ as the safety margin on each side of the changepoint.
Then we can assess how well we can detect this changepoint given the two sets of data points one each side of changepoint with the safety margin excluded.

Allele~B fractions cannot be easily segmented along the genome "as is", because their distribution in any given region has several modes.  However, if we assume normal genotypes are known and focus on loci that are heterozygous, then $\rho = \vert \beta - 1/2 \vert$ has only one mode and can be segmented easily~\cite{StaafJ_etal_2008}.
Here we will use genotype calls (always from the normal sample) to identify a set of loci that are heterozygous.
We focus on the SNPs in which we are the most confident that they are heterozygous: the evaluation will involve the <%=100*confQuantile%>\% SNPs with highest genotype confidence scores.

Whenever we compare different sets of data we constrain the number of data points to be the same for all data sets by sampling the minimum number of data points from each data set. Thus we know that we are actually comparing things at the same resolution.

\subsection{Receiver Operator Characteristic performance}
One approach is to use Receiver Operator Characteristic (ROC) analysis analogously to what is done in the (single-sample) evaluation method presented in \citet{BengtssonH_etal_2009b}.
Given the changepoint and excluding all loci within the safety margin, the remaining $J$ loci are split up in two data sets $\mathcal{J}_A = \{x_j \leq x_0 - \delta; j=1,\ldots,J\}$ and $\mathcal{J}_B = \{x_j > x_0 + \delta; j=1,\ldots,J\}$, where $x_j$ is the position of locus $j$ and $J$ is the total number of loci.  
Continuing, let $\mathcal{P}_s = \{\rho_j; j \in \mathcal{J}_s\}$ denote the (full-resolution) $\rho$ estimates of set $s \in \{A,B\}$ obtained by one of the preprocessing methods of interest.

Without loss of generality, assume the loci in $\mathcal{J}_A$ correspond to a balanced normal region PCN=(1,1) and the ones in $\mathcal{J}_B$ correspond to a deletion: PCN=(1,0).
By using a (global) threshold/cutoff $\tau$ we can then call the state for each locus.  We say that locus $j$ belongs to the state $B$ if $\rho_j \leq \tau$. Let $\mathcal{J}_{+} = \{\rho_j \leq \tau; j=1,\ldots,J\}$ be all such loci.  Let $\mathcal{J}_{-} = \{\rho_j > \tau; j=1,\ldots,J\}$ be the remaining loci, which are said to belong to state $A$. 
%%  As above, let $J_{+}$ and $J_{-}$ be the number of loci in each of these sets.
Then $\mathcal{J}_{+|B} = \mathcal{J}_{+} \cap \mathcal{J}_{B}$ represents the set of true positives (true deletions correctly called deletions) and $\mathcal{J}_{+|A} = \mathcal{J}_{+} \cap \mathcal{J}_{A}$ represents the set of false positives (true copy neutral loci incorrectly called deletions).
Finally, with $|\mathcal{J}|$ denoting the cardinality of the set $\mathcal{J}$, we define $\gamma = \gamma(\tau) = |\mathcal{J}_{+|B}| / |\mathcal{J}_{B}| \in [0,1]$ and $\alpha = \alpha(\tau) = |\mathcal{J}_{+|A}| / |\mathcal{J}_{A}| \in [0,1]$ to be the true-positive (TP) rate and the false-positive (FP) rate, respectively.  The Receiver Operator Characteristic (ROC) performance is defined by the ROC curve $R(\tau): \tau \rightarrow (\alpha,\gamma) \in [0,1]^2$.


\subsection{Performance at different levels of resolution}
By smoothing the data points in each set ($s = \{A,B\}$) by binning the loci in non-overlapping bins of width $h$, we can generate a new set of smoothed $\rho$ on which we can do ROC analysis.  Since the smoothed estimates are less noisy, the TP rate will increase at any given FP rate.  The price for achieving this is that the resolution at which we can detect change points decreases.


\subsection{Comparing methods}
For each method $p \in \{\textnormal{raw}; \textnormal{TBN,NGC}; \textnormal{TBN,Birdseed}\}$ we will obtain one ROC curve $R_{p}(\cdot)$. 
With standard ROC analysis we can then compare the relative performance of the different preprocessing methods.


%%For the case where there are two changepoints $x_A$ and $x_B$, we assume (where it is visually "obvious") that they divide up the local region into two similar data sets.  The region within the two breakpoints define the $\mathcal{J}_B$ set and the ones outside the $\mathcal{J}_A$ set.  


%=====================================================================
% Description of data set studied
%=====================================================================
\clearpage
\section{Data set}

<%
df <- getFile(fracBDsList[[1]],1);
tumorName <- getName(df);
normalName <- sub("ref=", "", getTags(df)[1]);
pairName <- paste(tumorName, normalName, sep=" / ");
chipTypeEsc <- gsub("_", "\\_", chipType, fixed=TRUE);
%>
The evaluation is this report is based on the tumor/normal pair (<%=tumorName%>,<%=normalName%>) for individual <%=tumorName%> in the data set <%=dataSet%>.  The data was generated on the <%=platform%> <%=chipTypeEsc%> chip type.  

<% if (platform == "Affymetrix") { %>
For Affymetrix, there is one CEL file per hybridization.  Each CEL file was preprocessed separately using CRMAv2~\citep{BengtssonH_etal_2009b}, without relying neither on reference samples nor prior estimates.
<% } else if (platform == "Illumina") { %>
<% } %>


<%
getRegionLabels <- function(state) {
  lab <- character(length=length(state));
  lab[state==0] <- "'normal' (1,1)";
  lab[state==1] <- "'gain' (1,2)";
  lab[state==2] <- "'deletion' (0,1)";
  lab[state==3] <- "'copy neutral LOH' (0,2)";
  lab;
} # getRegionLabels()

getRegionPcns <- function(state) {
  switch(state+1, c(1,1), c(1,2), c(0,1), c(0,2))
} # getRegionPcns()

getQuantStates <- function(states, evalSignal=c("TCN", "abs(fracB-1/2)", "minorCn", "majorCn")) {
  match.arg(evalSignal);

  pcns <- sapply(states, FUN=getRegionPcns);
  qs <- switch(evalSignal, 
    TCN = apply(pcns, MARGIN=2, FUN=sum),
    "abs(fracB-1/2)" = states,
    minorCn = pcns[1,],
    majorCn = pcns[2,]
  );

  ## if ties then order by TCN
  switch(length(unique(qs)), apply(pcns, MARGIN=2, FUN=sum), qs);
} # getQuantStates()
%>


%=====================================================================
% Description of change points studied
%=====================================================================
\subsection{List of change points}
For this data set, we have selected a few regions for which one safely can assume there exists a single changepoint and for which the fracB distribution looks constant.  This selection was done visually.  For each region we chose large enough safety margin such that the risk for the two sets $\mathcal{J}_A$ and $\mathcal{J}_B$ to contain loci from the other set is extremely small.  

\begin{table}[htp]
\begin{center}
\begin{tabular}{c|c|c|c|c|c}
Chr & Region & Change point & Margin & Before & After \\
\hline
<% for (region in regions) { %>
<%
firstRegion <- (region==regions[1]);
region <- parseRegion(region);
str(region);
sample <- region$name;
## sample <- pairName;
chr <- region$chromosome;
reg <- region$region/1e6;
## regionStr <- sprintf("%.2f", reg);
cp <- region$params$cp[1];
## cpStr <- sprintf("%.2f", cp);
delta <- region$params$cp[2];
## deltaStr <- sprintf("%.2f", delta);
regionLabels <- getRegionLabels(region$params$s);
%>
<%=chr%> & <%=reg[1]%>-<%=reg[2]%> & <%=cp%> & <%=delta%> & <%=regionLabels[1]%> & <%=regionLabels[2]%> \\ \hline
<% } # for (region ...) %>
\end{tabular}
\end{center}
\caption{Regions in <%=sample%> used for the evaluation and that each contain a single changepoint.  All positions and lengths are in units of Mb.}
\label{tblRegions}
\end{table}


We now compare the  raw, TBN-NGC, and TBN-Birdseed methods using the afformentioned ROC analysis at the full resolution as well as smoothed resolution with bin sizes $h=\{<%=paste(binCounts, collapse=", ")%>\}$.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% BEGIN Regions of interest
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<% for (region in regions) { %>
\clearpage
\section{Region: <%=region%>}
<%
print(region);
region <- parseRegion(region);
print(region);
%>


<%
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Count the number of loci with each state
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
getNbLociPerState <- function(object) {
  states <- getStates(object);
  tbl <- table(states, exclude=NULL);
  uniqueStates <- as.integer(names(tbl));
  o <- order(abs(uniqueStates));
  tbl <- tbl[o];
  names <- names(tbl);
  sign <- as.integer(names);
  names(tbl) <- getRegionLabels(sign);
  tbl
} # getNbLociPerState()
%>





<%
test <- function(signal, ...) {
  testSeparation(signal, test="ks.test")$statistic;
} # test()

test <- function(signal, testFUN, output=c("statistic")) {
  states <- getStates(signal);
  us <- na.omit(getUniqueStates(signal));
  testFUN(getSignals(signal)[states==us[1]], getSignals(signal)[states==us[2]])[[output]];
} # test()

allTstMeans <- NULL;
allTstSds <- NULL;
pcns <- NULL;
%>


<%
cnList <- NULL;
# Extract total CNs 
cnList <- getCnList(cnDsList, cnList=cnList, what="ratios", force=(figForce > 2));
cn <- cnList[[1]];
%>


%%%%%%%%%%%%
% fracB
%%%%%%%%%%%%

<% if (doFracB) { %>

<%
what <- "fracB";
enter(verbose, what);
signalList <- getFracBList(fracBDsList, what=what, pattern=methodPattern);

## remove NAs
signalList <- lapply(signalList, FUN=function(signal) {
  isNA <- is.na(getSignals(signal));
  signal <- extractSubset(signal, whichVector(!isNA));
})

signalList[["TCN"]] <- cn; ## Add TCN

if (byCount) {
  minNbrOfPoints <- min(sapply(signalList, FUN=function(signal) {
    table(getStates(signal));
  }));
  if (!useFixedNbrOfPoints) {
    minNbrOfPoints <- fixedNbrOfPoints;
  }

  if (useFixedSeed) {
     set.seed(seed);
   }
  signalList <- lapply(signalList, FUN=getBalancedRegions, minNbrOfPoints, replace=TRUE);
} # if (byCount)
%>

<%
caption <- sprintf("Test of the null hypothesis of equal distribution of %s before and after the breakpoint: Kolmogorov-Smirnov test statistic. The larger value, the more different the distributions are.", what);
testStat <- as.matrix(sapply(signalList, FUN=test, testFUN=ks.test));
rownames(testStat) <- names(signalList);
colnames(testStat) <- "ks";
display <- c("s", rep("fg", ncol(testStat)));
%>

\subsection{Test statistics: <%=what%>}
<%=print(xtable(testStat, caption=caption, display=display)) %>

Note that the number of loci in each state is constrained to be the same for all methods:
<%
tbl <- sapply(signalList, FUN=getNbLociPerState);
## stopifnot(all(rowSds(tbl) == 0));
tbl <- tbl[, 1];

caption <- "Number of loci in each state.";
df <- t(sapply(signalList, FUN=function(signal) {
  table(getStates(signal), exclude=NULL);
}));
colnames(df) <- names(tbl);
colnames(df)[colnames(df) == ""] <- "Safety Margin";
%>
<%=print(xtable(df, caption=caption)) %>

<%
exit(verbose);
%>

<% } ## if (doFracB) { %>

<%
what <- ifelse(evalSignal == "abs(fracB-1/2)", "mBAF", evalSignal);
%>

%%%%%%%%%%%%
% <%=what%>
%%%%%%%%%%%%


<% ## setup

signalList <- getFracBList(fracBDsList, what="fracB", pattern=methodPattern);
signalN <- getFracBList(list(dsN), what="fracB", force=(figForce > 2))[[1]];

enter(verbose, what);

###############
## BEGIN purifier
###############
enter(verbose, "purifier");
signalList <- lapply(signalList, FUN=function(signal) {
  signal$y <- (signal$y*cn$y-2*(1-kappaMain)*1/2) / (cn$y-2*(1-kappaMain));
  signal$y <- abs(signal$y-1/2);
  signal;
});

exit(verbose);
###############
## END purifier
###############

if (evalSignal == "minorCn" || evalSignal == "majorCn") {
  direction <- ifelse(evalSignal == "minorCn", -1, 1);
  enter(verbose, "Calculating minor/major CNs");
  signalList <- lapply(signalList, FUN=function(signal) {
    signal$y <- cn$y*(1/2 + direction*signal$y);
    signal;
  });

  exit(verbose);  
}

cn$y <- (cn$y-2*(1-kappaMain)) / kappaMain;

signal <- signalList[[1]];
signalList[["TCN"]] <- cn;
signalList[["TCN"]]$unit <- signalList[[1]]$unit;
 
signalList <- sapply(genTags, FUN=function(genTag) {
  extractHeterozygous(signalList, gcDsList[[genTag]], gcsDsList[[genTag]], confQuantile=confQuantile);
});
str(signalList);


## Number of het calls for each genotyping method, genome-wide.
## lapply(gcDsList, FUN=function(ds) {
##     df <- getFile(ds, 1); 
##     gens <- extractGenotypes(df); 
##     table(gens);
## });

dn <- dimnames(signalList);
nms <- sapply(dn[[2]], FUN=function(nm) sprintf("%s,%s", dn[[1]], nm));
nms <- as.character(nms);

nbrOfSets <- length(nms);
cols <- rep("black", times=nbrOfSets);
cols[regexpr("raw", nms) != -1] <- "black";
cols[regexpr("TCN", nms) != -1] <- "green";
cols[regexpr("TBN(,v[0-9]|),Birdseed", nms) != -1] <- "blue";
cols[regexpr("TBN(,v[0-9]|),NGC", nms) != -1] <- "red";

ltys <- rep(1, times=nbrOfSets);
ltys[regexpr("raw", nms) != -1] <- 2;  # dot-dashed
ltys[regexpr("TCN", nms) != -1] <- 3;  # dotted
ltys[regexpr("TBN(,v[0-9]|),Birdseed", nms) != -1] <- 4; # dashed

labels <- strsplit(nms, split="\n");
labels <- sapply(labels, FUN=function(s) s[1]);
 
patts <- c("raw", sprintf("%s,%s", dn[[2]], dn[[2]]), "TCN");
keep <- unlist(sapply(patts, FUN=grep, nms));
##    keep <- seq(nms);
signalList <- signalList[keep];
names(signalList) <- nms[keep];

cols <- cols[keep];
ltys <- ltys[keep];
labels <- labels[keep];
nms <- nms[keep];
%>

<%  ## Add TCN
signalList[["TCN,SNP+CN"]] <- cn;
snps <- whichVector(!is.na(signal$y));
signalList[["TCN,SNP"]] <- extractSubset(cn, snps);

if (byCount) {
  minNbrOfPoints <- min(sapply(signalList, FUN=function(signal) {
    table(getStates(signal));
  }));
  if (!useFixedNbrOfPoints) {
   binCounts <-  binCounts * fixedNbrOfPoints/minNbrOfPoints;
    minNbrOfPoints <- fixedNbrOfPoints;
  }
  if (useFixedSeed) {
     set.seed(seed);
  }    
  signalList <- lapply(signalList, FUN=getBalancedRegions, minNbrOfPoints, replace=TRUE);
} # if (byCount)

cols <- c(cols,  rep("darkgreen", 2));
ltys <- c(ltys,  2, 3);
nms <- names(signalList);
labels <- c(labels, "TCN,SNP+CN", "TCN,SNP");
%>

<% ## keep only some combinations for the evaluation
if (!plotAllRocCurves) {
  keep <- grep(rocCurvesPattern, names(signalList));
  signalList <- signalList[keep];
  cols <- cols[keep];
  ltys <- ltys[keep];
  nms <- nms[keep];
  labels <- labels[keep];
} # if (!plotAllRocCurves)
%>

<%
tbl <- sapply(signalList, FUN=getNbLociPerState);
## stopifnot(all(rowSds(tbl) == 0));
tbl <- tbl[, 1];
%>

\subsection{Test statistics: <%=what%>}

<%
testNames <- c("Student"="t", "Kolmogorov-Smirnov"="ks");
testStat <- NULL;
for (testLabel in names(testNames)) {
  testName <- testNames[testLabel];
  fcnName <- sprintf("%s.test", testName);
  testFUN <- get(fcnName, mode="function");
  testStat <- rbind(testStat, sapply(signalList, FUN=test, testFUN=testFUN));
  rm(testFUN);

  ## constrain the nb of point to be the same across regions?
  fixedNbPointsAcrossRegions <- (testName == "t");

  ## a combination not implemented yet:
  if (!fixedNbPointsAcrossMethods) {
    if (fixedNbPointsAcrossRegions) {
      warning("Allowing number of points to vary across methods *and* regions");
      fixedNbPointsAcrossRegions <- FALSE;
    }
    doB <- FALSE;
    B <- 1;
  }
} # for (testName ...)
colnames(testStat) <- names(signalList);
rownames(testStat) <- testNames;

caption <- sprintf("Significance of the breakpoint in the distributions of %s for heterozygous SNPs:Kolmogorov-Smirnov (equality of the distribution before and after the breakpoint) and Student (equal mean before and after the breakpoint) test statistics. The larger in absolute value, the more significant the breakpoint is.", what);
display <- c("s", rep("fg", nrow(testStat)));
%>

<%=print(xtable(t(testStat), caption=caption, display=display)) %>

Note that the number of loci in each state is constrained to be the same for all methods:

<%
caption <- "Number of loci in each state";
df <- t(sapply(signalList, FUN=function(signal) {
  table(getStates(signal), exclude=NULL);
}));
colnames(df) <- names(tbl);
colnames(df)[colnames(df)==""] <- "Safety Margin";
row.names(df) <- labels;
%>
<%=print(xtable(df, caption=caption)) %>

<% if (plotTracks) { %>
\clearpage
\subsection{<%=what%> tracks}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN FIGURE: eval tracks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<%
rhoLim <- c(0, 0.4);
rhoLab <- expression(rho);
rhoLabT <- expression(tilde(rho));

cnLim <- c(0, 5);
cnLab <- expression(C == 2*(theta[T]/theta[N]));
cnLab <- "C";

xScale <- 1e-6;
xRange <- range(sapply(signalList, FUN=xRange));
states <- na.omit(getUniqueStates(signalList[[1]]));
xlim <- xRange*xScale;
cp <- region$params$cp;
s <- region$params$s;
xs <- cp["position"]+c(-1,+1)*cp["delta"];
figList <- list();
for (kk in seq(along=signalList)) {
  name <- names(signalList)[kk];
  signal <- signalList[[kk]];

  addStateLabels <- FALSE;
  ylim <- cnLim;
  if (length(grep("TCN", name))) {
    addStateLabels <- TRUE;
    ylab <- cnLab;
    figTag <- "ratios"
  } else if (evalSignal == "majorCn") {
    ylab <- expression(C[2]);
    figTag <- "majorCn";
  } else if (evalSignal == "minorCn") {
    ylab <- expression(C[3]);
    figTag <- "minorCn";
  } else {
    ylim <- rhoLim;
    if (length(grep("TBN", name))) {
      ylab <- rhoLabT;
    } else {
      ylab <- rhoLab;
    }
    figTag <- "MBAF";
  }

 setStateColorMap(signal,fullResColorMap);
  

  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
  # Plot along genome
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  figName <- sprintf("%s,%s,track,%s", region$label, figTag, name);
  if (fig <- figDev(figName, aspect=trackAspect)) {
    # subplots(nbrOfSources, ncol=1);
    par(mar=c(1.2,2,0.1,0)+0.2, mgp=c(1.2,0.3,0), tcl=-0.3, cex=cex, cex.axis=0.7);
    
    plot(signal, pch=pch, cex=cex, xlim=xlim, ylim=ylim, xScale=xScale, ylab=ylab);
    if (addStateLabels) {
      stext(side=3, pos=0, line=-0.2, cex=0.8*cex, names(tbl[1]))
      stext(side=3, pos=1, line=-0.2, cex=0.8*cex, names(tbl[2]))
    }

    ys <- par("usr")[3:4];
    dy <- 0.04*diff(ys);
    if (s[1] != 0) {
      rect(xlim[1],ys[1],xs[1],ys[1]+dy, col="#999999");
    } else {
      rect(xs[2],ys[1],xlim[2],ys[1]+dy, col="#999999");
    }
    rect(xs[1],ys[1],xs[2],ys[2], density=10, col="#999999");
##     stext(side=4, pos=1, line=-0.7, cex=cex, name, las=3);
  if (addSdEst) {
      sd <- estimateStandardDeviation(signal);
      stext(side=4, pos=1, line=-0.7, cex=0.8*cex, sprintf("SD=%.3g", sd));
    }
    if (addBinTrack) {
      binWidths <- binCounts;
      binWidth <- binWidths[length(binWidths)];
      if (!byCount) {
        binWidth <- round(diff(xRange(signal))/(nbrOfLoci(signal, na.rm=TRUE)-1)*binWidth)
      }
    signalS <- binnedSmoothingByState(signal, from=xRange[1], to=xRange[2], by=binWidth, FUN=binFFracB, byCount=byCount);
      setStateColorMap(signalS, smoothedColorMap);
      lines(signalS, lty=1, lwd=2, col="white", xScale=xScale);
      points(signalS, pch=19, cex=.7, col="white", xScale=xScale);
      lines(signalS, lty=3, lwd=1, xScale=xScale);
      points(signalS, pch=19, cex=.5, xScale=xScale);
    }
    ts <- signif(test(signal, testFUN=ks.test), digits=2)
 ##    stext(side=4, pos=0, line=-0.7, cex=0.8*cex, sprintf("KS = %s",ts), las=3)

   devDone(figName);
  } # if (figDev(...))
  figList[[kk]] <- fig;
} # for (kk ...)
%>

\begin{figure}[htb]
 \begin{center}
  <% for (fig in figList) { %>
  \resizebox{\trackWidth}{!}{\includegraphics{<%=figPath%>/<%=fig$fullname%>}}
  <% } %>
 \end{center}
 \caption{<%=what%> for region <%=region$src%>. Only heterozygous SNPs are plotted. There are <%=tbl[1]%> loci of state <%=names(tbl)[1]%> ("negatives") and
  <%=tbl[2]%> loci of state <%=names(tbl)[2]%> ("positives"), where the
  latter are highlighted with a solid bar beneath. 
  In total <%=tbl[3]%> loci within the safety margin were excluded.
 }
 \label{fig<%=figName%>}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END FIGURE: rho tracks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<% } ## if (plotTracks) { %>

\clearpage
\subsection{ROC curves}
% We focus on heterozygous SNP as called by <%=genTag%>. 
Smoothing is done using the <%=binFFracB%> function.

<%
binWidths <- binCounts;
if (byCount) {
} else {     
  binWidths <- round(diff(xRange(signalList[[1]]))/(nbrOfLoci(signalList[[1]], na.rm=TRUE)-1)*binWidths)
}
%>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN Figure
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<%
  rocRows <- ceiling(length(binCounts)/rocCols); 
  aspect <- rocRows/rocCols;

  signal <- signalList[[1]];
  nbrOfLoci <- sum(is.finite(signal$y), na.rm=TRUE);
  fullRes <- (diff(xRange(signal))+1) / (nbrOfLoci-1);
  
  xRange <- range(sapply(signalList, FUN=xRange));
  states <- na.omit(getUniqueStates(signal));
%>

\begin{figure}[htb]
 \begin{center}
<%   for (ww in seq(along=binWidths)) {
       binWidth <- binWidths[ww];
      
       smtFUN <- function(signal) {
           signalS <- binnedSmoothingByState(signal, from=xRange[1], to=xRange[2], 
           by=binWidth, FUN=binFFracB, byCount=byCount);
         signalS <- extractSubsetByState(signalS, states=states);
         signalS;
       }

       if (kappaMain != 1) {
         figName <- sprintf("%s,ROC,%s,binWidth=%s,kappa=%s", region$label, robustStr, binWidth, kappaMain);
       } else {
         figName <- sprintf("%s,ROC,%s,binWidth=%s", region$label, robustStr, binWidth);
       }
       if (fig <- figDev(figName, aspect=1, scale=0.5)) {
         ##   layout(matrix(seq(along=binWidths), ncol=rocCols, byrow=TRUE));
         par(mar=c(2.5,2.4,1.3,1)+0.1, mgp=c(1.4,0.3,0), tcl=-0.3, cex=cex);
    
     if (binWidth > 0) {
       # Smooth signal using consecutive bins of given width (in kb)
       signalSList <- lapply(signalList, FUN=smtFUN);
       dim(signalSList) <- dim(signalList)
        names(signalSList) <- names(signalList)

       if (byCount) {
         binLabel <- sprintf("Bin size: %g", round(binWidth));
       } else {
         binLabel <- sprintf("Bin width %g kb", binWidth/1e3);
      }
   } else {
      signalSList <- signalList;
      binLabel <- sprintf("Full resolution (%.1f kb, %s points)", fullRes/1e3, length(signal$unit));
    }
    print(signalSList);
  
    fits <- NULL;
    for (ss in seq(along=signalSList)) {
      signalS <- signalSList[[ss]];
      cat("Number of missing values: ", sum(is.na(getSignals(signalS))), "\n", sep="");
      es <- ifelse(length(grep("TCN", names(signalList)[ss])), "TCN", evalSignal);
      cat("Evaluation statistics:", es, "\n");
      cat("States:", states, "\n");
      qs <- getQuantStates(states, es);
      cat("qs=", qs, "\n");
      recall <- states[which.min(qs)]; ## In 'fitRoc', 'recall' is in fact the neutral state
      cat("Recall:", recall ,"\n");
      roc <- fitRoc(signalS, states=states, recall=recall);
      fits <- append(fits, list(roc));
    }
    names(fits) <- names(signalSList);     
  
   for (kk in seq(fits)) {
     doLgd <- ((kk == 1) && (ww == length(binWidths)) && (ww > 1));
     fit <- fits[[kk]];
     roc <- fit$roc;
     if (kk==1) {
       plot(roc, type="l", lwd=3, col=cols[kk], lty=ltys[kk], xlim=fpLim, ylim=sort(1-fpLim), xlab="False-positive rate", ylab="True-positive rate");
       abline(a=0, b=1, lty=3);
       stext(side=3, pos=1, binLabel, line=0, cex=0.8*cex);
     } else {
       lines(roc, lwd=3, col=cols[kk], lty=ltys[kk]);
     }
     pcns <- sapply(states, FUN=getRegionPcns);
     pcnTxt <- apply(pcns, MARGIN=2, FUN=function(x) sprintf("(%s,%s)", x[1], x[2]));
     pcnTxt <- paste(pcnTxt, collapse=" vs ");
     stext(side=3, pos=0, pcnTxt, line=0, col="#999999", cex=0.8*cex);
     stext(side=4, pos=0, what, col="#999999", line=-0.4);
     stext(side=4, pos=1, sprintf("k=%s", kappaMain), col="#999999", line=-0.4);

     if (addLegend && doLgd) {
       legend("bottomright", col=cols, lwd=2, lty=ltys, labels, cex=0.4, bty="n");
     }
   } # for (kk ...)
   devDone(figName);
 } # if (figDev(...)) %> 
\resizebox{0.45\textwidth}{!}{\includegraphics{<%=figPath%>/<%=fig$fullname%>}}  <% } # for (ww ...) %>
\end{center}
 \caption{(<%=region$src%>) ROC curves for each of the <%=length(fracBDsList)%> preprocessing methods at the full resolution as well as <%=length(binWidths)-1%> different amounts of smoothing (using the <%=binFFracB%> function).  %Legend: raw (solid red), TBN-Birdseed (dashed blue) and TBN-NGC (solid light blue).
}
 \label{fig<%=figName%>}
\end{figure}

<% 
  ltyLgds <- rep("solid", length(ltys))
  ltyLgds[ltys==2] <- "dashed"
  ltyLgds[ltys==3] <- "dotted"
  ltyLgds[ltys==4] <- "dash-dotted"
  
  lgd <- cbind(ltyLgds, cols)
  rownames(lgd) <- nms
  colnames(lgd) <- c("line type", "color")
  
  caption <- sprintf("Legend of Figure \\ref{fig%s}.", figName)
%>
<%=print(xtable(lgd, caption=caption)) %>


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END Figure
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<%
exit(verbose);
%>

\clearpage
\subsection{$(\beta_N, \beta_T)$ plots}
<%
verbose && enter(verbose, "Plotting (beta_N, beta_T)")
what <- "fracB"
fracBList <- getFracBList(fracBDsList, what=what, pattern=methodPattern, force=(figForce > 2));

fracBN <- getFracBList(list(dsN), what=what, force=(figForce > 2))[[1]];
betaN <- getSignals(fracBN);

print(fracBList);
nbrOfSources <- length(fracBList);
%>
<%
 xScale <- 1e-6;
 cp <- region$params$cp;
  s <- region$params$s;
 
  xlab <- expression(beta[N] == theta[B,N]/theta[N]);
  ylab <- expression(beta[T] == theta[B,T]/theta[T]);
  xlab <- expression(beta[N]);
  ylab <- expression(beta[T]);
  lim <- c(-0.1,1.1);

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
# Plot $(\beta_N, \beta_T)$
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
%>
<%
tbl <- sapply(fracBList, FUN=getNbLociPerState);
stopifnot(all(rowSds(tbl) == 0));
tbl <- tbl[, 1]
%>
<%  for (kk in seq(along=fracBList)) { %>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% BEGIN Figure: (betaN, betaT) for each state separately: <%=names(fracBList)[kk]%>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\begin{figure}[htb]
  \begin{center}
<%
    name <- names(fracBList)[kk];
    fracB <- fracBList[[kk]];
    ustates <- na.omit(getUniqueStates(fracB));
    for (ss in seq(along=ustates)) {
      fracBState <- extractSubsetByState(fracB, state=ustates[ss]);
      fracBNState <- extractSubsetByState(fracBN, state=ustates[ss]);
      betaN <- getSignals(fracBNState)

      betaT <- getSignals(fracBState);

      ## genotype calls
      genName <- unlist(strsplit(name, ","))
      genName <- genName[length(genName)]
      gTag <- ifelse(genName=="raw", genTag, genName);
     gcN <- gcDsList[[gTag]]
      idx <- indexOf(gcN, region$name);
      gf <- getFile(gcN, idx);
      isHet <- isHeterozygous(gf, units=fracBNState$unit, drop=TRUE);
      
      col <- rep(homCol, length(isHet));
      col[isHet] <-hetCol;

      figName <- sprintf("%s,betaNvsBetaT,%s,%s,%s,state=%s", region$label, what, name, gTag, ustates[ss]);
      if (fig <- figDev(figName)) {
        par(mar=c(2.7,2.6,1.2,0)+0.1, mgp=c(1.4,0.3,0), tcl=-0.3, cex=cex);
        plot(NA, xlim=lim, ylim=lim, xlab=xlab, ylab=ylab, axes=FALSE);
        axis(side=1, at=c(0,1/2,1));
        axis(side=2, at=c(0,1/2,1));
##        box();  # optional?

        if (addDiagHorizLines) {	
          as <- seq(-1.5, 1.5, by=.1);
          b <- ifelse(name == "raw", 1, 0);
          la <- lapply(as, FUN=function(x) abline(a=x, b=b, col="#999999", lty=1, lwd=1));
	}

        ## boxes
        z <- 0:2/2;
        a <- rep(min(z), length(z));
        b <- rep(max(z), length(z));
        segments(a, z, b, z, col="#999999", lty=2);
        segments(z, a, z, b, col="#999999", lty=2);

        points(betaN, betaT, pch=pch, col=col, cex=cex);

        if ((addTrueBetaLines) && (name =="raw")) {
          ## slope: exploiting symmetries...
          slopeDatAbove <- betaT/betaN;
          slopeDatBelow <- (1-betaT)/(1-betaN);
          slopeDat <- slopeDatAbove;
          slopeDat[which(slopeDat>1)] <- slopeDatBelow[which(slopeDat>1)];
          
          hetSlope <- median(slopeDat[isHet], na.rm=TRUE);
          
          abline(a=0, b=1, lty=2, lwd=2, col="#999999");
          x0 <- rep(0, 2);
          x1 <- rep(1, 2);
          y0 <- c(0, 1-hetSlope);
          y1 <- c(hetSlope, 1);
          segments(x0, y0, x1, y1, lty=1, lwd=6, col="white");
          segments(x0, y0, x1, y1, lty=1, lwd=4, col=hetCol);
        }
        
##         if ((addLinearRegressionLines) && (name =="raw")) {
        if ((addLinearRegressionLines)) {
          
          if (name =="raw") {
            isBelow <- (betaT < betaN);
          } else {
            isBelow <- (betaT<1/2);
         };
          wBelow <- whichVector(isHet & isBelow);
          wAbove <- whichVector(isHet & !isBelow);
          xxBelow <- c(betaN[wBelow], 1-betaN[wAbove]);
          yyBelow <- c(betaT[wBelow], 1-betaT[wAbove]);
          xxAbove <- 1-xxBelow;
          yyAbove <- 1-yyBelow;
        
          lmBelow <- lm(betaT[wBelow]~betaN[wBelow]);
          lmAbove <- lm(betaT[wAbove]~betaN[wAbove]);

          ##           lmBelow <- rlm(betaT[wBelow]~betaN[wBelow], weights=abs(betaN[wBelow]-1/2));
          ##           lmBelow <- rlm(betaT[wBelow]~betaN[wBelow]);
          lmBelow <- rlm(yyBelow~xxBelow);
          ##           lmAbove <- rlm(betaT[wAbove]~betaN[wAbove], weights=abs(betaN[wAbove]-1/2));
          ##           lmAbove <- rlm(betaT[wAbove]~betaN[wAbove]);
          lmAbove <- rlm(yyAbove~xxAbove);

          xb <- 1/2;
          abline(lmBelow, lwd=9, col="white");
          abline(lmBelow, lwd=6, col=hetCol, lty=1);
          coef <- lmBelow$coefficients
          yb <- coef[1]+xb*coef[2];
          points(xb, yb, col="white", cex=2.6, pch=20);
          points(xb, yb, col=hetCol, cex=2, pch=20);
          abline(lmAbove, lwd=9, col="white");
          abline(lmAbove, lwd=6, col=hetCol, lty=1);
          coef <- lmAbove$coefficients
          yb <- coef[1]+xb*coef[2];
         points(xb, yb, col="white", cex=2.6, pch=20);
         points(xb, yb, col=hetCol, cex=2, pch=20);
         points(xb, yb, col=hetCol, cex=2, pch=1);
       }
        
       txt <- sprintf("%s,%s", name, gTag);
        nm <- names(tbl)[ss];
        stext(side=4, pos=0, line=-0.8, cex=cex, txt, col="#999999");
        stext(side=3, pos=0, line=-0.3, cex=cex, nm);

        if (addTrueBetaPoints) {         ## add points for true allele B fractions
         for (kk in seq(along=kappasPbs)) {
            kappa <- kappasPbs[kk];
            tbc <- (3:5)[kk];
            tbCex <- c(2, 1.5, 1)[kk];
            points(0,0, col=tbc, cex=tbCex, pch=20);
            points(1,1, col=tbc, cex=tbCex, pch=20);
            trueBeta <- switch(nm,
              "NORMAL (1,1)" = 1/2,
              "GAIN (1,2)" = (1*kappa+(1-kappa))/(3*kappa+2*(1-kappa)),
              "DELETION (0,1)" = (1-kappa)/(kappa+2*(1-kappa)),
              "COPY NEUTRAL LOH (0,2)" = (1-kappa)/2);
            points(1/2, trueBeta, col=tbc, cex=tbCex, pch=20)
            points(1/2, 1-trueBeta, col=tbc, cex=tbCex, pch=20)
          }
        }
        devDone(figName);
      } # if (figDev(...)) %>\resizebox{0.34\textwidth}{!}{\includegraphics{<%=figPath%>/<%=fig$fullname%>}}
      <%  } # for (ss ...) %>
    \end{center}
    \caption{<%=txt%>.}
   \label{fig<%=figName%>}
    \end{figure}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
    % END Figure
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
<%         if (name =="raw") { %>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% BEGIN Figure: (betaN, betaT) for each state separately: <%=names(fracBList)[kk]%>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\begin{figure}[htb]
  \begin{center}
<%
    name <- names(fracBList)[kk];
    fracB <- fracBList[[kk]];
    ustates <- na.omit(getUniqueStates(fracB));
    for (ss in seq(along=ustates)) {
      fracBState <- extractSubsetByState(fracB, state=ustates[ss]);
      fracBNState <- extractSubsetByState(fracBN, state=ustates[ss]);
      betaN <- getSignals(fracBNState)

      betaT <- getSignals(fracBState);

      ## genotype calls
      genName <- unlist(strsplit(name, ","))
      genName <- genName[length(genName)]
      gTag <- ifelse(genName=="raw", genTag, genName);
      gcN <- gcDsList[[gTag]]
      idx <- indexOf(gcN, region$name);
      gf <- getFile(gcN, idx);
      isHet <- isHeterozygous(gf, units=fracBNState$unit, drop=TRUE);
      
      col <- rep(homCol, length(isHet));
      col[isHet] <-hetCol;

      isBelowDiagonal <- (betaT<betaN);
      xx <- median(betaN[isBelowDiagonal & isHet], na.rm=TRUE);
      yy <- median(betaT[isBelowDiagonal & isHet], na.rm=TRUE);

      figName <- sprintf("%s,betaNvsBetaT,%s,%s,%s,smoothScatter,state=%s", region$label, what, name, gTag, ustates[ss]);
      if (fig <- figDev(figName)) {
        par(mar=c(2.7,2.6,1.2,0)+0.1, mgp=c(1.4,0.3,0), tcl=-0.3, cex=cex);
        smoothScatter(betaN, betaT, xlim=lim, ylim=lim, xlab=xlab, ylab=ylab, axes=FALSE)
       axis(side=1, at=c(0,1/2,1));
        axis(side=2, at=c(0,1/2,1));
##        box();  # optional?

        abline(a=0, b=yy/xx)
        abline(v=xx)
        abline(v=.5)
        abline(h=yy)
        abline(h=yy/xx*.5)

        txt <- sprintf("%s,%s --- smoothScatter version", name, gTag);
        stext(side=4, pos=0, line=-0.8, cex=cex, txt, col="#999999");
        stext(side=3, pos=0, line=-0.3, cex=cex, names(tbl)[ss]);
        devDone(figName);
      } # if (figDev(...)) %>\resizebox{0.34\textwidth}{!}{\includegraphics{<%=figPath%>/<%=fig$fullname%>}}
      <%  } # for (ss ...) %>
    \end{center}
    \caption{<%=txt%>.}
   \label{fig<%=figName%>}
    \end{figure}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
    % END Figure
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
      <%  } # if (name ... %>
 <%  } # for (kk ...) %>


\clearpage
\subsection{Density plots}
<%
verbose && enter(verbose, "Plotting densities");
what <- "fracB";
fracBList <- getFracBList(fracBDsList, what=what, pattern=methodPattern, force=(figForce > 2));
# Sanity check
stopifnot(length(fracBList) %in% c(2,3));   # raw, Birdseed*, NGC
ustates <- na.omit(getUniqueStates(fracBList[[1]]));
%>

<%
tbl <- sapply(fracBList, FUN=getNbLociPerState);
stopifnot(all(rowSds(tbl)==0));
tbl <- tbl[, 1];
%>

<%
xlab <- expression(beta[T]);
lim <- c(-0.1,1.1);
%>

<%
xlim <- c(-0.2,1.2);
platform <- getPlatform(fracBDsList[[1]]);
if (platform == "Affymetrix") {
  adjust <- 0.5; ylim <- c(0,3.2);
  adjust <- 0.3; ylim <- c(0,4.0);
} else if (platform == "Illumina") {
  adjust <- 0.3; ylim <- c(0,6.0);
}
%>

\begin{figure}[htb]
 \begin{center}
<%
for (ss in seq(along=ustates)) {
  ustates <- na.omit(getUniqueStates(fracB));
  figName <- sprintf("%s,%s,density,state=%s", region$label, what, ustates[ss]);
  fracBStateList <- lapply(fracBList, FUN=extractSubsetByState, ustates[ss]);
  betaT <- sapply(fracBStateList, FUN=getSignals);
%>%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% BEGIN Figure: betaT densities for state <%=ustates[ss]%>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
  \subfloat[<%=names(tbl)[ss]%>.]{
    <% 
    if (fig <- figDev(figName, aspect=0.4)) {
      par(mar=c(2.7,0.2,1.2,0.2)+0.1, mgp=c(1.4,0.3,0), tcl=-0.3, cex=cex);
      plotDensity(betaT, col=c("#999999", "#999999", "#000000"), lty=c(3,1,1), lwd=6, adjust=adjust, xlim=xlim, ylim=ylim, xlab=xlab, ylab=NULL, axes=FALSE);
      axis(side=1, labels=FALSE, col.ticks=NA);
      axis(side=1, at=c(0,1/2,1));
      stext(side=3, pos=0.5, line=0, margin=c(0.2,0), cex=cex, names(tbl)[ss]);
      devDone(figName);
    } # if (figDev(...)) 
    %>%
   \resizebox{0.34\textwidth}{!}{\includegraphics{<%=figPath%>/<%=fig$fullname%>}}%
  } % \subfloat{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% END Figure
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
<%  } # for (ss ...) %>
 \end{center}
 \caption{Density plots.}
 \label{fig<%=figName%>}
\end{figure}

<% verbose && exit(verbose); %>


%\clearpage
\subsection{Allele-specific copy number estimates}
<%
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
# Plot ASCNs
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
verbose && enter(verbose, "Plotting (C_A,C_B)")
what <- "ratios";

xlab <- expression(C["TA"] == theta["TA"]/theta[N]);
ylab <- expression(C["TB"] == theta["TB"]/theta[N]);
xlab <- expression(C["TA"]);
ylab <- expression(C["TB"]);
lim <- c(-0.5,4.5);

# Extract total CNs 
cnList <- getCnList(cnDsList, what=what, force=(figForce > 2));
cn <- cnList[[1]];
print(cn);
C <- getSignals(cn);
col <- getStateColors(cn, na.rm=TRUE);

fracBList <- getFracBList(fracBDsList, what="fracB", pattern=methodPattern, force=(figForce > 2));
print(fracBList);
nbrOfSources <- length(fracBList);

  xScale <- 1e-6;
  states <- na.omit(sort(getUniqueStates(fracBList[[1]])));
  cp <- region$params$cp;
  s <- region$params$s;
%>

<%
tbl <- sapply(fracBList, FUN=getNbLociPerState);
stopifnot(all(rowSds(tbl) == 0));
tbl <- tbl[, 1];
%>

<%  for (kk in seq(along=fracBList)) { %>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% BEGIN Figure: (C_A, C_B) for each state separately: <%=names(fracBList)[kk]%>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\begin{figure}[htb]
  \begin{center}
<%
    name <- names(fracBList)[kk];
    fracB <- fracBList[[kk]];
    ustates <- na.omit(getUniqueStates(fracB));
    for (ss in seq(along=ustates)) {
      state <- ustates[ss];
      cnState <- extractSubsetByState(cn, state=state);
      fracBState <- extractSubsetByState(fracB, state=state);
      fracBNState <- extractSubsetByState(fracBN, state=state);

      C <- getSignals(cnState);
      beta <- getSignals(fracBState);
      # Sanity check
      stopifnot(length(beta) == length(C));

      CA <- (1-beta) * C;
      CB <- beta * C;
 
      ## genotype calls
      genName <- unlist(strsplit(name, ","))
      genName <- genName[length(genName)]
      gTag <- ifelse(genName=="raw", genTag, genName);
      gcN <- gcDsList[[gTag]]
      idx <- indexOf(gcN, region$name);
      gf <- getFile(gcN, idx);
      isHet <- isHeterozygous(gf, units=fracBNState$unit, drop=TRUE);
      
      col <- rep(homCol, length(isHet));
      col[isHet] <-hetCol;

      figName <- sprintf("%s,ASCN,%s,%s,%s,state=%s", region$label, what, name, gTag, state);
      if (fig <- figDev(figName)) {
        par(mar=c(2.7,2.6,1.2,0)+0.1, mgp=c(1.4,0.3,0), tcl=-0.3, cex=cex);
        plot(NA, col=col, xlim=lim, ylim=lim, xlab=xlab, ylab=ylab);
        for (c in 2) lines(x=c(0,c), y=c(c,0), lty=1, lwd=2, col="#999999");
        ## boxes
        rLim <- c(floor(lim[1]), ceiling(lim[2]));
        z <- seq(from=rLim[1], to=rLim[2]);
        a <- rep(min(z), length(z));
        b <- rep(max(z), length(z));
        segments(a, z, b, z, col="#999999", lty=2);
        segments(z, a, z, b, col="#999999", lty=2);

        txt <- sprintf("%s,%s", name, gTag);
        stext(side=4, pos=0, line=-0.8, cex=cex, txt, col="#999999");
        stext(side=3, pos=1, line=-0.3, cex=cex, names(tbl)[ss]);
        points(CA, CB, col=col, pch=pch, cex=cex);
        devDone(figName);
      } # if (figDev(...)) %>\resizebox{0.34\textwidth}{!}{\includegraphics{<%=figPath%>/<%=fig$fullname%>}}
 <% } # for (ss ...) %>
    \end{center}
    \caption{<%=txt%>.}
      \label{fig<%=figName%>}
    \end{figure}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
    % END Figure
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
 <%  } # for (kk ...) %>

<% verbose && exit(verbose); %>


<% } # for (region ...) %>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END Regions of interest
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\clearpage
\section{Bootstrap estimates of test statistics for all regions}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN Regions of interest
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<% for (testLabel in names(testNames)) { %>

<% 
allTstMeans <- NULL;
allTstSds <- NULL;
pcns <- NULL;
%>

<% for (region in regions) { %>
<%
firstRegion <- (region == regions[1]);
print(region);
region <- parseRegion(region);
print(region);
%>
%%%%%%%%
%% TCN
%%%%%%%%
<%
cnList <- NULL;
# Extract total CNs 
cnList <- getCnList(cnDsList, cnList=cnList, what="ratios", force=(figForce > 2));
cn <- cnList[[1]];
%>

<%
## PCN states
pcns <- c(pcns, attr(region$params$s, "src"));
%>

<% 
for (what in evalSignals) { 
  for (probeType in probeTypes) { 

    signalList <- getFracBList(fracBDsList, what=what, pattern=methodPattern);

    ## remove NAs
    signalList <- lapply(signalList, FUN=function(fracB) {
      isNA <- is.na(getSignals(fracB));
      fracB <- extractSubset(fracB, whichVector(!isNA));
    });

    signalList[["TCN"]] <- cn; ## Add TCN
    signalList[["TCN"]]$unit <- signalList[[1]]$unit;

    if (probeType == "Het SNPs") {
      signalList <- sapply(genTags, FUN=function(genTag) {
        extractHeterozygous(signalList, gcDsList[[genTag]], gcsDsList[[genTag]], confQuantile=confQuantile);
      });

      dn <- dimnames(signalList);
      nms <- sapply(dn[[2]], FUN=function(nm) sprintf("%s,%s", dn[[1]], nm));
      nms <- as.character(nms);

      patts <- c("raw", sprintf("%s,%s", dn[[2]], dn[[2]]), "TCN");
      keep <- unlist(sapply(patts, FUN=grep, nms));
      signalList <- signalList[keep];
      names(signalList) <- nms[keep];

      ## Add TCN
      signalList[["TCN,SNP+CN"]] <- cn;
      snps <- whichVector(!is.na(signalList[[1]]$y))
      signalList[["TCN,SNP"]] <- extractSubset(cn, snps)

      ## keep only some combinations for the evaluation
      if (!keepAllCombinations) {
        keep <- grep(rocCurvesPattern, names(signalList))
        signalList <- signalList[keep];
      }
    } # if (probeType == "Het SNPs")
    str(signalList);

    if (!fixedNbPointsAcrossRegions && fixedNbPointsAcrossMethods) {
      minNbPoints <- min(sapply(signalList, FUN=function(fracB) {
        table(getStates(fracB));
      }));
    }

    testName <- testNames[testLabel];
    fcnName <- sprintf("%s.test", testName);
    testFUN <- get(fcnName, mode="function");

    width <- getOption("width")-2;
    pb <- ProgressBar(max=width, stepLength=width/B);
    reset(pb);
    tstB <- sapply(1:B, FUN=function(x) {
      if (fixedNbPointsAcrossMethods) {
        signalListB <- lapply(signalList, FUN=getBalancedRegions, minNbPoints);
      } else {
        signalListB <- signalList;
      }
      tst <- sapply(signalListB, FUN=test, testFUN=testFUN, output=output);
      increase(pb);
      tst;
    });
    cat("\n");

    if (output == "p.value") {
      tstB <- -log(tstB);
    }
    tstB <- abs(tstB);

    tstMeans <- rowMeans(tstB);
    tstSds <- rowSds(tstB);
   
    names(tstMeans) <- names(signalList);
    allTstMeans[[what]][[probeType]] <- cbind(allTstMeans[[what]][[probeType]], tstMeans);
    allTstSds[[what]][[probeType]] <- cbind(allTstSds[[what]][[probeType]], tstSds);
  } ## for (probeType ...)
} ## for (what ...)
%>

<% } # for (region in regions) %>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END Regions of interest
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<%
for (what in evalSignals) {
  for (probeType in probeTypes) {
    tstMeans <- allTstMeans[[what]][[probeType]];
    tstSds <- allTstSds[[what]][[probeType]];
    # Sanity check
    stopifnot(all.equal(dim(tstMeans), dim(tstSds)));
  
    # Bootstrap results?
    if (doB) {
      tab <- sprintf("%.3f%s%.3f", tstMeans, pmTag, tstSds);
    } else {
      tab <- sprintf("%.3f", tstMeans);    
    }
  
    tab <- matrix(tab, nrow=nrow(tstMeans), ncol=ncol(tstMeans));
    rownames(tab) <- names(signalList);
    colnames(tab) <- pcns;
    what2 <- ifelse(what == "fracB", "beta", "rho");
    output2 <- ifelse(output == "statistic", "test statistics", "p-value");

    if (doB) {
      txtB <- sprintf("Mean %s standard deviation of %s subsamplings of the original data set. ", pmTag, B);
    } else {
      txtB <- "";
    }

    caption <- sprintf("%s %s of the null hypothesis of equal mean before and after each PCN change point (%s): raw or TumorBoost-normalized %s, and total copy number (last line). %sThe larger value, the more different the distributions are.", testLabel, output2, probeType, what2, txtB);

    label <- sprintf("tab%s%s%s", testName, what2, toCamelCase(probeType));

    xt <- xtable(tab, caption=caption, label=label);
    buf <- capture.output(print(xt));
    buf <- sprintf("%s\n", buf);
    tabStr <- gsub(pmTag, "$\\pm$", buf, fixed=TRUE);
    %><%=print(tabStr)%><%
   } ## for (probeType ...)
} ## for (what ...)
%>

<% } # for (testLabel ...) %>



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%   APPENDIX
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%=====================================================================
% References
%=====================================================================
\clearpage
\bibliography{bioinformatics-journals-abbr,hb-at-maths.lth.se}
%\bibliographystyle{plain}
\bibliographystyle{natbib}


%=====================================================================
% Data files
%=====================================================================
\clearpage
\appendix
\section{Data files}
\begin{Verbatim}[fontfamily=helvetica]
<%={x <- capture.output(print(fracBDsList));x <- gsub(": .*/(totalAndFracBData/)", ": \\1", x);paste(x, collapse="\n");}%>
\end{Verbatim}


%=====================================================================
% Session information
%=====================================================================
\clearpage
\section{Session information}
This report was automatically generated using the R.rsp package.
<%=toLatex(sessionInfo())%>


\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% HISTORY:
% 2009-11-24 [HB]
% o Merged with tables.tex.rsp too.
% o Merged main.tex.rsp and plotByStates.tex.rsp.
% 2009-10-06 [PN]
% o ?
% 2009-08-23
% o Added evaluation based on major and minor CNs.
% 2009-09-06
% o WORKAROUND: For some unknown reasons does \graphicspath{} not 
%   work anymore; added explicity paths to figures.
% o Moved document configs to R/002.config.R.
% 2009-08-23
% o Updated the line styles ('ltys').
% 2009-07-02
% o Added support for PNG output.
% 2009-07-01
% o Added (betaN, betaT) plots stratified by state showing lines that
% motivate the correction factor in TBN,v2.
% 2009-06-30
% o Fixed byCount=FALSE.
% o Constrained the number of points to be the same for comparisons at a given resolution.
% 2009-06-29
% o Removed TBN (v1) tracks and ROC curves.
% o Added several flavors of ROC curves for total copy numbers.
% 2009-06-23
% o Fixed number of loci and state legends in figure captions.
% o Added tables with results of 'ks.test' and 't.test' to the evaluation.
% 2009-06-22
% o Added ks.test()$stat to fracB tracks.
% o Now only one panel in each figure.
% o Nicer plots.
% 2009-06-15
% o Added (betaN, betaT) plots.
% 2009-06-13
% o Added a track for ASCN.
% 2009-06-11
% o Added a track for TCN.
% 2009-06-10
% o Added a track for fracB.
% 2009-06-08
% o Replaced 'cn' by 'fracB'. Updated text accordingly.
% 2009-04-09
% o Language updates after feedback from TS.
% 2009-02-23
% o Created.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
