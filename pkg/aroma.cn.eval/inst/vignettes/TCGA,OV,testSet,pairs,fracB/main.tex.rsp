%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Authors: Henrik Bengtsson, hb@stat.berkeley.edu
%          Pierre Neuvial, pierre@stat.berkeley.edu
% Created on: 2009-02-23
% Modified on: 2009-06-08
%
% Usage:
%  library("R.rsp");
%  rsptex("main.tex.rsp");  # => *.tex.rsp => ... => *.dvi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
<%
verbose && enter(verbose, "Setup");
sourceDirectory("R/");
what <- "fracB";
addLegend <- FALSE;
addSdEst <- FALSE;
addBinTrack <- FALSE;

binWidths <- c(0,1,2,5,10,20)*1e3; rocCols <- 2;
binWidths <- c(0,5,20,50,100,200)*1e3; rocCols <- 3;
binWidths <- c(0,20,50,100,200,400)*1e3; rocCols <- 3;
robust <- c(FALSE, TRUE)[2];
robustStr <- ifelse(robust, "median", "mean");
binFFracB <- ifelse(robust, "median", "mean"); 

figPath <- "figures/col/";
figForce <- TRUE;
figDev <- function(..., force=figForce) { epsDev(..., path=figPath, force=force) }
getStateColors.SegmentedGenomicSignalsInterface <- function(this, ...) {
  states <- getStates(this)
  col <- rep("#000000", nbrOfLoci(this));
  col[states < 0] <- "blue"
  col[states > 0] <- "red"
  col[is.na(states)] <- "#999999";
  col
}

title <- sprintf("Single sample assessment of the TumorBoost method based on the '%s' data set", dataSet);
authors <- "HB, PN.";
verbose && exit(verbose);
%>

%\documentclass[a4paper,draft]{article}
\documentclass[a4paper]{article}
\usepackage{graphicx}
\usepackage{fancyvrb}
\usepackage{a4wide}
\usepackage{xspace}
\usepackage{amsmath} 
\usepackage{natbib}

% The search path (within curly brackets and separated by commas)
% where to find graphics files
\graphicspath{{<%=figPath%>}}
\DeclareGraphicsRule{.eps.gz}{eps}{.eps.bb}{`gunzip -c #1}

\newcommand{\pkg}[1]{\textsl{#1}\xspace}

\title{<%=title%>}
\author{<%=authors%>}

\begin{document}

\maketitle

\section{Introduction}
This report provides a single-sample approach to assess the performance of the TumorBoost method.  The results presented herein are intended to complement the results presented in the main manuscript.

\section{Method}
Consider a local genomic region with loci where there exists exactly one change point in the distribution of the allele B fraction (fracB, or $\beta$) at position $x_0$ and that the true distribution at each side of the changepoint is constant.

Assume that we can identify this changepoint and with very high confidence locate it to be within $[x_0-\delta, x_0+\delta)$ where we refer to $\delta$ as the safety margin on each side of the changepoint.
Then we can assess how well we can detect this changepoint given the two sets of data points one each side of changepoint with the safety margin excluded.

Allele~B fractions cannot be easily segmented along the genome "as is", because their distribution in any given region has several modes.  However, if we assume normal genotypes are known and focus on loci that are heterozygote, then $\rho = \vert \beta - 1/2 \vert$ has only one mode and can be segmented easily.
Here we will use normal genotype calls to identify a set of loci that are heterozygote.


\subsection{Receiver Operator Characteristic performance}
One approach is to use Receiver Operator Characteristic (ROC) analysis analogously to what is done in the (single-sample) evaluation method presented in \citet{BengtssonH_etal_2009b}.
Given the changepoint and excluding all loci within the safety margin, the remaining $J$ loci are split up in two data sets $\mathcal{J}_A = \{x_j \leq x_0 - \delta; j=1,\ldots,J\}$ and $\mathcal{J}_B = \{x_j > x_0 + \delta; j=1,\ldots,J\}$, where $x_j$ is the position of locus $j$ and $J$ is the total number of loci.  
Continuing, let $\mathcal{P}_s = \{\rho_j; j \in \mathcal{J}_s\}$ denote the (full-resolution) $\rho$ estimates of set $s \in \{A,B\}$ obtained by one of the preprocessing methods of interest.

Without loss of generality, assume the loci in $\mathcal{J}_A$ correspond to a balanced normal region PSCN=(1,1) and the ones in $\mathcal{J}_B$ correspond to a deletion: PSCN=(1,0).
By using a (global) threshold/cutoff $\tau$ we can then call the state for each locus.  We say that locus $j$ belongs to the state $B$ if $\rho_j \leq \tau$. Let $\mathcal{J}_{+} = \{\rho_j \leq \tau; j=1,\ldots,J\}$ be all such loci.  Let $\mathcal{J}_{-} = \{\rho_j > \tau; j=1,\ldots,J\}$ be the remaining loci, which are said to belong to state $A$. 
%%  As above, let $J_{+}$ and $J_{-}$ be the number of loci in each of these sets.
Then $\mathcal{J}_{+|B} = \mathcal{J}_{+} \cap \mathcal{J}_{B}$ represents the set of true positives (true deletions correctly called deletions) and $\mathcal{J}_{+|A} = \mathcal{J}_{+} \cap \mathcal{J}_{A}$ represents the set of false positives (true copy neutral loci incorrectly called deletions).
Finally, with $|\mathcal{J}|$ denoting the cardinality of the set $\mathcal{J}$, we define $\gamma = \gamma(\tau) = |\mathcal{J}_{+|B}| / |\mathcal{J}_{B}| \in [0,1]$ and $\alpha = \alpha(\tau) = |\mathcal{J}_{+|A}| / |\mathcal{J}_{A}| \in [0,1]$ to be the true-positive (TP) rate and the false-positive (FP) rate, respectively.  The Receiver Operator Characteristic (ROC) performance is defined by the ROC curve $R(\tau): \tau \rightarrow (\alpha,\gamma) \in [0,1]^2$.

\paragraph{\bf Note:} Too many $\beta$ here.


\subsection{Performance at different levels of resolution}
By smoothing the data points in each set ($s = \{A,B\}$) by binning the loci in non-overlapping bins of width $h$, we can generate a new set of smoothed $\rho$ on which we can do ROC analysis.  Since the smoothed estimates are less noisy, the TP rate will increase at any given FP rate.  The price for achieving this is that the resolution at which we can detect change points decreases.

\subsection{Comparing methods}
For each method $p \in \{\textnormal{raw}; \textnormal{TBN,NGC}; \textnormal{TBN,Birdseed}\}$ we will obtain one ROC curve $R_{p}(\cdot)$. 
With standard ROC analysis we can then compare the relative performance of the different preprocessing methods.


%%For the case where there are two changepoints $x_A$ and $x_B$, we assume (where it is visually "obvious") that they divide up the local region into two similar data sets.  The region within the two breakpoints define the $\mathcal{J}_B$ set and the ones outside the $\mathcal{J}_A$ set.  


\section{Data set}

<%
df <- getFile(dsList[[1]],1);
tumorName <- getName(df);
normalName <- sub("ref=","",getTags(df)[1]);
pairName <- paste(tumorName, normalName, sep=" / ");
%>
This report is based on the data set <%=dataSet%>. All data is based on the Affymetrix GenomeWideSNP\_6 chip type.  This evaluation will be based on $\rho$ estimated from one such pair, more precisely the <%=tumorName%> CEL file (tumor) and the <%=normalName%> CEL file (matched normal).

The two CEL files were preprocessed separately using CRMAv2 (without any reference arrays)

\subsection{List of change points}
For this data set, we have selected a few regions for which one safely can assume there exists a single changepoint and for which the fracB distribution looks constant.  This selection was done visually.  For each region we chose large enough safety margin such that the risk for the two sets $\mathcal{J}_A$ and $\mathcal{J}_B$ to contain loci from the other set is extremely small.  

\begin{table}[htp]
\begin{center}
\begin{tabular}{c|c|c|c|c}
Tumor-normal pair & Chromosome & Region & Change point & Safety region \\
\hline
<% for (region in regions) { %>
<%
region <- parseRegion(region);
str(region);
sample <- region$name;
sample <- pairName;
chr <- region$chromosome;
regionStr <- sprintf("%.2f", region$region/1e6);
cp <- region$params$cp[1];
cpStr <- sprintf("%.2f", cp);
delta <- region$params$cp[2];
deltaStr <- sprintf("%.2f", delta);
%>
<%=sample%> & <%=chr%> & <%=regionStr[1]%>-<%=regionStr[2]%> & <%=cpStr%> & <%=deltaStr%> \\
\hline
<% } # for (region ...) %>
\end{tabular}
\end{center}
\caption{Regions used for the evaluation and that each contain a single changepoint.  All positions and lengths are in units of Mb.}
\label{tblRegions}
\end{table}


We now compare the  raw, TBN-NGC, and TBN-Birdseed methods using the afformentioned ROC analysis at the full resolution as well as smoothed resolution with bin sizes $h=\{<%=paste(sprintf("%.1f", binWidths[-1]/1e3), collapse=", ")%>\}$~kb.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN Regions of interest
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<% # regions <- regions[1]; %>
<% for (region in regions) { %>
\clearpage
\section{Region: <%=region%>}

<%
print(region);
region <- parseRegion(region);
print(region);
%>


<%
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Count the number of loci with each state
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
what <- "abs(fracB-1/2)";
fracBList <- getFracBList(NULL, what=what, force=TRUE);
print(fracBList);
fracB <- fracBList[[1]];
rm(fracBList);
states <- getStates(fracB);
rm(fracB);
tbl <- table(states, exclude=NULL);
uniqueStates <- as.integer(names(tbl));
o <- order(abs(uniqueStates));
tbl <- tbl[o];
rm(o, uniqueStates);
names <- names(tbl);
sign <- as.integer(names(tbl));
names[sign ==  0] <- "'COPY NEUTRAL' (s=0)";
names[sign == -1] <- "'LOSS' (s=-1)";
names[sign == +1] <- "'GAIN' (s=+1)";
names(tbl) <- names;
rm(sign);
%>




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN Figure: Total copy number
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Total copy number}
<%
what <- "ratios";
cnList <- NULL;
figName <- sprintf("%s,%s,track", region$label, what);
if (fig <- figDev(figName, aspect=0.618)) {
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
  # Plot CN ratios along genome
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  cnList <- getCnList(cnList, what=what, force=TRUE);
  print(cnList);
  
  nbrOfSources <- length(cnList);
  subplots(nbrOfSources, ncol=1);
  par(mar=c(2.7,2.6,0.2,1)+0.1, mgp=c(1.4,0.3,0), tcl=-0.3, cex=1.2);
  pch <- "."; cex <- 2;
  xScale <- 1e-6;
  xRange <- range(sapply(cnList, FUN=xRange));
  states <- na.omit(getUniqueStates(cnList[[1]]));
  
  cp <- region$params$cp;
  s <- region$params$s;
  cnLab <- "CN";
  if (what == "log2ratios") {
    cnLim <- c(-3,3);
    cnLab <- expression(M == log[2](theta[T]/theta[N]));
  } else {
    cnLim <- c(-0.5,6);
    cnLab <- expression(C == 2*(theta[T]/theta[N]));
  }
  
  for (kk in seq(along=cnList)) {
    cn <- cnList[[kk]];
    name <- names(cnList)[kk];
    xlim <- xRange*xScale;
  
    plot(cn, pch=pch, cex=0.8*cex, xlim=xlim, ylim=cnLim, xScale=xScale, ylab=cnLab);
    xs <- cp["position"]+c(-1,+1)*cp["delta"];
    ys <- par("usr")[3:4];
    dy <- 0.04*diff(ys);
    if (s[1] != 0) {
      rect(xlim[1],ys[1],xs[1],ys[1]+dy, col="#999999");
    } else {
      rect(xs[2],ys[1],xlim[2],ys[1]+dy, col="#999999");
    }
    rect(xs[1],ys[1], xs[2],ys[2], density=10, col="#999999");
    stext(side=3, pos=0.02, line=-1, cex=1.0, name);
    if (kk == 1) {
      stext(side=3, pos=0.98, line=-1.1, cex=0.8, sprintf("Chr%02d", getChromosome(cn)));
    }
    if (addSdEst) {
      sd <- estimateStandardDeviation(cn);
      stext(side=4, pos=1, line=0, cex=0.8, sprintf("SD=%.3g", sd));
    }
    if (addBinTrack) {
      binWidth <- 10e3;
      cn <- extractSubsetByState(cn, states=states);
      cnS <- binnedSmoothingByState(cn, from=xRange[1], to=xRange[2], by=binWidth);
      points(cnS, pch=pch, cex=0.8*cex, col="white", xScale=xScale);
      points(cnS, pch=19, cex=0.6*cex, col="orange", xScale=xScale);
    }
  
  } # for (kk ...)
  devDone(figName);
} # if (figDev(...))
%>
\begin{figure}[htb]
 \begin{center}
  \resizebox{0.95\textwidth}{!}{\includegraphics{<%=fig$fullname%>}}
 \end{center}
 \caption{(<%=region$src%>) 
  There are <%=tbl[1]%> loci of state <%=names(tbl)[1]%> ("negatives") and
  <%=tbl[2]%> loci of state <%=names(tbl)[2]%> ("positives"), where the
  latter are highlighted with a solid bar beneath. 
  In total <%=tbl[3]%> loci within the safety margin were excluded.
 }
 \label{fig<%=figName%>}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END Figure: Total copy number
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



<%
whats <- c("fracB", "fracB", "abs(fracB-1/2)");
figTags <- c("BAF", "BAF,hets", "MBAF,hets");
keepOnlyHets <- c(FALSE, TRUE, TRUE);
%>

<% for (ww in seq(along=whats)) {
  what <- whats[ww];
  figTag <- figTags[ww];
  fracBList <- NULL;
%>

\clearpage

\subsection{<%=what%>}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN Figure:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<%
figName <- sprintf("%s,%s,track", region$label, figTag);
if (fig <- figDev(figName)) {

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
# Plot 'what' along genome
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
fracBList <- getFracBList(NULL, what=what, force=figForce, 
                                      keepOnlyHets=keepOnlyHets[ww]);
print(fracBList);

nbrOfSources <- length(fracBList);
subplots(nbrOfSources, ncol=1);
par(mar=c(2.7,2.6,1.0,1)+0.1, mgp=c(1.4,0.3,0), tcl=-0.3, cex=1.2);
pch <- 19; cex <- 0.7;
pch <- "."; cex <- 2;
xScale <- 1e-6;
xRange <- range(sapply(fracBList, FUN=xRange));
states <- na.omit(getUniqueStates(fracBList[[1]]));
cp <- region$params$cp;
s <- region$params$s;
fracBLab <- "FracB";
if (what == "fracB") {
  fracBLim <- c(-0.1,1.1);
  fracBLab <- expression(beta == theta[B]/(theta[A]+theta[B]));
}
 
if (what == "abs(fracB-1/2)") {
  maxRho <- sapply(fracBList, function(x) max(x$y, na.rm=TRUE))
  fracBLim <- c(-0.02, max(maxRho));
  fracBLab <- expression(rho == abs(beta - 1/2));
}

for (kk in seq(along=fracBList)) {
  name <- names(fracBList)[kk];
  fracB <- fracBList[[kk]];
  xlim <- xRange*xScale;
  plot(fracB, pch=pch, cex=0.8*cex, xlim=xlim, ylim=fracBLim, xScale=xScale, ylab=fracBLab);
  xs <- cp["position"]+c(-1,+1)*cp["delta"];
  ys <- par("usr")[3:4];
  dy <- 0.04*diff(ys);
  if (s[1] != 0) {
    rect(xlim[1],ys[1],xs[1],ys[1]+dy, col="#999999");
  } else {
    rect(xs[2],ys[1],xlim[2],ys[1]+dy, col="#999999");
  }
  rect(xs[1],ys[1], xs[2],ys[2], density=10, col="#999999");
  stext(side=3, pos=0, line=0, cex=1.0, name);
  if (kk == 1) {
    stext(side=3, pos=1, line=0, cex=1.0, sprintf("Chr%02d", getChromosome(fracB)));
  }
  if (addSdEst) {
    sd <- estimateStandardDeviation(fracB);
    stext(side=4, pos=1, line=0, cex=0.8, sprintf("SD=%.3g", sd));
  }
  if (addBinTrack) {
    binWidth <- 10e3;
    fracB <- extractSubsetByState(fracB, states=states);
    fracBS <- binnedSmoothingByState(fracB, from=xRange[1], to=xRange[2], by=binWidth, FUN=binFFracB);
    points(fracBS, pch=pch, cex=0.8*cex, col="white", xScale=xScale);
    points(fracBS, pch=19, cex=0.6*cex, col="orange", xScale=xScale);
  }
} # for (kk ...)
devDone(figName);

} # if (figDev(...))
%>
\begin{figure}[htb]
 \begin{center}
  \resizebox{0.95\textwidth}{!}{\includegraphics{<%=fig$fullname%>}}
 \end{center}
 \caption{(<%=region$src%>) 
  There are <%=tbl[1]%> loci of state <%=names(tbl)[1]%> ("negatives") and
  <%=tbl[2]%> loci of state <%=names(tbl)[2]%> ("positives"), where the
  latter are highlighted with a solid bar beneath. 
  In total <%=tbl[3]%> loci within the safety margin were excluded.
 }
 \label{fig<%=figName%>}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END Figure
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage

<% } # for (ww in ...) %>




\subsection{Allele-specific copy number estimates}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN Figure:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<%
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
# Plot ASCNs
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
verbose && enter(verbose, "Plotting (C_A,C_B)")
fracBList <- getFracBList(NULL, what="fracB", force=figForce, 
                                                  keepOnlyHets=FALSE);
print(fracBList);
nbrOfSources <- length(fracBList);

what <- "ratios";
cnList <- getCnList(cnList, what=what);
cn <- cnList[[1]];
print(cn);
 
 
figName <- sprintf("%s,ASCN,%s", region$label, what);
if (fig <- figDev(figName, aspect=1.12*(1/nbrOfSources))) {
  subplots(nbrOfSources, ncol=nbrOfSources);
  par(mar=c(2.7,2.6,1.2,0)+0.1, mgp=c(1.4,0.3,0), tcl=-0.3, cex=1.2);
  pch <- 19; cex <- 0.7;
  pch <- "."; cex <- 2;
  xScale <- 1e-6;
  states <- na.omit(sort(getUniqueStates(fracBList[[1]])));
  cp <- region$params$cp;
  s <- region$params$s;
 
  xlab <- expression(C[A] == theta[A,T]/theta[N]);
  ylab <- expression(C[B] == theta[B,T]/theta[N]);
  xlab <- expression(C[T][","][A] == theta[T][","][A]/theta[N]);
  ylab <- expression(C[T][","][B] == theta[T][","][B]/theta[N]);
  xlab <- expression(C[T][","][A] == (1-beta[T])*C);
  ylab <- expression(C[T][","][B] == beta[T]*C);
  xlab <- expression(C["T,A"]);
  ylab <- expression(C["T,B"]);
  lim <- c(-0.5,4.5);

  # Extract total CNs 
  C <- getSignals(cn);
  col <- getStateColors(cn);

  for (kk in seq(along=fracBList)) {
    name <- names(fracBList)[kk];
    fracB <- fracBList[[kk]];
    beta <- getSignals(fracB);
    CA <- (1-beta) * C;
    CB <- beta * C;
    plot(CA, CB, col=col, xlim=lim, ylim=lim, pch=pch, cex=0.8*cex, xlab=xlab, ylab=ylab);
    stext(side=3, pos=0, line=0, cex=1.0, name);
  } # for (kk ...)
 
  devDone(figName);
} # if (figDev(...))
verbose && exit(verbose);
%>
\begin{figure}[htb]
 \begin{center}
  \resizebox{0.95\textwidth}{!}{\includegraphics{<%=fig$fullname%>}}
 \end{center}
 \caption{(<%=region$src%>) 
  There are <%=tbl[1]%> loci of state <%=names(tbl)[1]%> ("negatives") and
  <%=tbl[2]%> loci of state <%=names(tbl)[2]%> ("positives"). 
  In total <%=tbl[3]%> loci within the safety margin were excluded.
 }
 \label{fig<%=figName%>}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END Figure
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage

\subsection{Evaluation}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN Figure
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<%
figName <- sprintf("%s,ROC,%s", region$label, robustStr);
rocRows <- ceiling(length(binWidths)/rocCols);
aspect <- rocRows/rocCols;
if (fig <- figDev(figName, width=8, aspect=aspect)) {
what <- whats[ww];
fracBList <- getFracBList(NULL, what=what);
print(fracBList);

fracB <- fracBList[[1]];
nbrOfLoci <- sum(is.finite(fracB$y), na.rm=TRUE);
fullRes <- (diff(xRange(fracB))+1) / (nbrOfLoci-1);

xRange <- range(sapply(fracBList, FUN=xRange));
states <- na.omit(getUniqueStates(fracB));

layout(matrix(seq(along=binWidths), ncol=rocCols, byrow=TRUE));
par(mar=c(2.5,2.4,1.3,0.7)+0.1, mgp=c(1.4,0.3,0), tcl=-0.3, cex=1.2);
fpLim <- c(0,0.40);
fpLim <- c(0,0.5);
for (ww in seq(along=binWidths)) {
  binWidth <- binWidths[ww];

  if (binWidth > 0) {
    # Smooth FracBs using consecutive bins of given width (in kb)
    fracBSList <- lapply(fracBList, FUN=function(fracB) {
      fracBS <- binnedSmoothingByState(fracB, from=xRange[1], to=xRange[2], by=binWidth, FUN=binFFracB, verbose=verbose);
      fracBS <- extractSubsetByState(fracBS, states=states);
      fracBS;
    }) 
    binLabel <- sprintf("Bin width %g kb", binWidth/1e3);
  } else {
    fracBSList <- fracBList;
    binLabel <- sprintf("Full resolution (%.1f kb)", fullRes/1e3);
  }
  print(fracBSList);

  fits <- lapply(fracBSList, FUN=function(fracBS) {
    cat("Number of missing values: ", sum(is.na(fracBS$fracB)), "\n", sep="");
    fitRoc(fracBS, states=states, recall=states[1]);
  });

  cols <- c("red", "blue", "lightblue", "green");
  ltys <- c(1,4,1,3);
  cols <- rep(cols, length.out=length(fits));
  ltys <- rep(ltys, length.out=length(fits));

  for (kk in seq(along=fits)) {
    fit <- fits[[kk]];
    roc <- fit$roc;
    if (kk == 1) {
      plot(roc, type="l", lwd=3, col=cols[kk], lty=ltys[kk], xlim=fpLim, ylim=sort(1-fpLim), xlab="False-positive rate", ylab="True-positive rate");
      abline(a=0, b=1, lty=3);
      stext(side=3, pos=1, binLabel);
    } else {
      lines(roc, lwd=3, col=cols[kk], lty=ltys[kk]);
    }
    if (addLegend && kk == 1) {
      labels <- strsplit(names(fracBSList), split="\n");
      labels <- sapply(labels, FUN=function(s) s[1]);
      legend("bottomright", col=cols, lwd=2, lty=ltys, labels, cex=0.8, bty="n");
    }
  } # for (kk ...)
} # for (ww ...)
  devDone(figName);
} # if (figDev(...))
%>
\begin{figure}[htb]
 \begin{center}
  \resizebox{0.9\textwidth}{!}{\includegraphics{<%=fig$fullname%>}}
 \end{center}
 \caption{(<%=region$src%>) ROC curves for each of the <%=length(dsList)%> preprocessing methods at the full resolution as well as <%=length(binWidths)-1%> different amounts of smoothing.  Legend: raw (solid red), TBN-NGC (dashed blue) and TBN-Birdseed (solid light blue).}
 \label{fig<%=figName%>}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END Figure
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


<% } # for (region in regions) %>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END Regions of interest
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% References
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\bibliography{bioinformatics-journals-abbr,hb-at-maths.lth.se}
%\bibliographystyle{plain}
\bibliographystyle{natbib}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Session information
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\appendix
\section{Data files}
\begin{Verbatim}[fontfamily=helvetica]
<%={x <- capture.output(print(dsList));x <- gsub(": .*/(totalAndFracBData/)", ": \\1", x);paste(x, collapse="\n");}%>
\end{Verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Session information
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\section{Session information}
This report was automatically generated using the R.rsp package.
<%=toLatex(sessionInfo())%>


\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% HISTORY:
% 2009-06-13
% o Added a track for ASCN.
% 2009-06-11
% o Added a track for TCN.
% 2009-06-10
% o Added a track for fracB.
% 2009-06-08
% o Replaced 'cn' by 'fracB'.
% o Updated text accordingly.
% 2009-04-09
% o Language updates after feedback from TS.
% 2009-02-23
% o Created.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
